# 

# 面试经历


## 简历
1. 热爱移动产品研发，
2. 熟练掌握java、kotlin，数据Android SDK、熟悉Android的UI/网络/数据库框架
3. 具备Android开发经验，能独立开发Android App
4. 对软件产品有强烈的责任心，具备良好的沟通能力和优秀的团队协作能力



1. 卡顿监控
2. 连续掉帧  流畅率 指标是怎么样的

## 项目

### 话题列表页
1. MVI Flow搭建Redux核心框架  上报也是使用action
2. 演变 MVI雏形，viewmodel暴露dispatch接口-> 讨论架构，引入redux -> 存在ViewAction和StateAction -> 存在usecase层，抽出viewmodel中可复用的逻辑 -> 新增ReportAction用于上报 -> 引入middleware，usecase中的逻辑迁移到此 -> 去除ViewAction
3. Repository对外暴露数据的接口使用Flow承载
4. 包括为了兼容旧的业务逻辑，以前是存在很多EventBus的方式接受请求回报，统一封装在repository层，对外屏蔽EventBus，这种应该退出历史舞台
5. View可以内部闭环的逻辑就没必要通过Viewmodel去处理了
6. 历史债：使用jce定义的数据结构，非data class，无法做数据diff
7. 为什么UiState下还要区分HasData、NoData
8. 如果列表中的Item的功能足够复杂，所以会拆分为多个区域去处理对应的UI显示以及以及业务逻辑，与此同时，对应的区域存在对应的数据去描述，而且需要处理局部刷新的问题：对比数据变化->UI变化的区域，使用payload去进行刷新，如果用户的一个操作会导致多个UI区域刷新，则需要payload多个数据到recyclerView的item，所以getChangePayload中的逻辑则是这样的：创建一个用于list用于容纳payloads，如果某个区域数据变化，则add该区域的payload数据，对应的区域处理对应的payload
9. EventBus收归到Repository，EventBusRepository，对外提供flow
10. copy不会导致内存爆掉吗？因为state都是用的copy的方式去描述页面状态的变化，答案当然是不会，state的变化并不是深拷贝，而是拷贝所变化的部分，也就是差异化拷贝，可以理解state是一个树状的一个结构，一般来说state树发生变化也只是叶子节点的数据发生变化，每一次的变化不会涉及到整个state的对象的深拷贝，所以内存的压力可以不用考虑
11. 

### 

## 复习

### 操作系统

#### 分页
##### 疑问
1. 页帧号为什么要左移再加上偏移量?

页帧号左移再加上偏移量是因为在虚拟内存系统中，一个进程的虚拟地址空间被划分为多个固定大小的页（Page）或页面，而物理内存也被划分为相同大小的页框（Page Frame）。

当进程需要访问一个虚拟地址时，操作系统需要将该虚拟地址转换为物理地址，这个转换的过程就叫做地址映射。地址映射的过程包括两个步骤：

1 将虚拟地址中的页号与物理地址中的页帧号进行映射；
2 将虚拟地址中的页内偏移量加上物理地址中的页帧内偏移量。

因此，将页帧号左移再加上偏移量的操作实际上是完成了第二步的地址映射操作，将虚拟地址中的页内偏移量加上了物理地址中的页帧内偏移量，从而得到了最终的物理地址。

需要注意的是，页帧号左移的位数是根据页面大小来确定的。例如，如果页面大小为4KB，那么页帧号需要左移12位，因为2的12次方等于4KB。因此，物理地址的前几位是页帧号，后面的几位是页帧内偏移量。


#### 疑问
- [ ] 为什么多队列多处理器调度（MQMS）虽然通过工作窃取（Work Stealing）避免了负载不均的问题，但是就会出现缓存亲和性的问题啊？还是说这个问题相对负载不均并不是那么严重？？？

### Android

#### 常见的框架

##### Glide

##### OKHttp

###### 设计模式
- 责任链模式
拦截器链：
1. RetryAndFollowUpInterceptor 重试和重定向拦截器，负责网络请求重定向、重试逻辑
2. BridgeInterceptor 桥接拦截器，从应用程序代码到网络代码的桥梁，首先从用户请求构建网络请求，然后继续调用网络，最后根据网络响应构建用户响应
3. CacheInterceptor 缓存拦截器，请求缓存相关逻辑以及将响应写入缓存，包括缓存策略
4. ConnectInterceptor 连接拦截器，打开与目标服务的连接
5. CallServerInterceptor 请求服务器拦截器，对服务器进行网络调用

开发者可以自行添加拦截器，包括应用拦截器、网络拦截器；

应用拦截器处于内部拦截器之前，网络拦截器处于CallServerInterceptor之前，ConnectInterceptor之后

#### 虚拟机
[dalvik vs art](https://www.jianshu.com/p/1361d1e3a344)

#### Binder

- 为什么AMS和zygote进程通信不用Binder，而是socket？因为fork操作不能在多线程的环境下
[为什么SystemServer进程与Zygote进程通讯采用Socket而不是Binder](https://codeantenna.com/a/jj2VwT8qlS)

##### mmap
mmap是一种内存映射文件的方法，它将一个文件映射到进程的地址空间中，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映的关系。实现这样
的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动会写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必要再调用read、write等系统
调用函数。相反，内核空间对这段内存区域的修改也直接反映用户空间，从而实现不同进程间的数据共享

![pc](https://upload-images.jianshu.io/upload_images/13774375-211e6032044be1ba?imageMogr2/auto-orient/strip|imageView2/2/w/682/format/webp)


#### 模块化
1. 模块之间的通信？

单工程->模块化->组件化

模块化：按业务模块来划分
组件化：各个业务会依赖到的可重用的逻辑，比如说日志组件、网络组件、ui组件等

而模块之间的通信呢？

我们这边是用的Router，各个模块会依赖Router基础库，向外部暴露统一的接口，注册到Router中，因此各个模块都可以通过Router来获取到其他模块对外暴露的接口，通过Router的中转，依赖接口隔离各个模块的具体的实现逻辑，所以各模块之间的依赖关系是很清晰的。

api 对外暴露的类？



### Java基础

#### 动态代理
[Android插件化原理解析——Hook机制之动态代理](https://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/)

#### JMM
1. 工作内存和主内存
2. 工作内存和主内存之间存在一套协议
3. 多线程环境下要保证线程之间共享变量的可见性
4. volatile关键字 [java单例模式与指令重排](http://chen-tao.github.io/2016/12/30/about-java-singleton/)

#### 并发

5. 锁优化技术：锁粗化、锁消除、锁升级
6. 偏向锁->轻量级锁->自旋锁->自适应自旋锁->重量级锁
7. monitorenter、monitorexit
8. CAS compare and swap

##### 生产者消费者
- 为什么condition.signal要在lock.unlock之前，这之间的是怎么运作的？
[ReentrantLock中Condition的wait方法、signal方法简单场景回顾](https://codeantenna.com/a/6YTX3qDfFG)

##### ConcurrentHashmap
[深入解析ConcurrentHashMap：感受并发编程智慧](https://segmentfault.com/a/1190000038416595)

### Android
#### ViewModel
1. 生命周期是怎么样的

2.0之前空的Fragment

2.0以后，AndroidX的支持，LifecycleOwner支持


## 面试题目

- 聊一下 Binder 的实现，如果让你 hook binder 拿到 binder 里面传输的数据你会怎么做
[Android知识体系之Binder Hook](https://www.zybuluo.com/TryLoveCatch/note/2287028)
- MVC & MVP & MVVM，这么多设计模式你都用过，你觉得哪个更好，他们之前主要的差别是什么
[Android架构学习之路三-MVX](https://ljd1996.github.io/2022/01/11/Android%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B8%89-MVX/)
- 聊一下 coroutines 的底层实现
首先我们

自我介绍：
面试官你好，我叫王强，毕业于长沙理工大学，实习和毕业后都一直在腾讯pcg工具产品中心这个团队，团队一开始是负责微视发布器的业务，就是负责拍摄、视频的剪辑发布的流程，然后我这边主要也是负责各个模块上层的业务逻辑开发，后来同时也启动了鹅剪的项目的开发，我这边参与比较少，同期也是在负责微视这边业务的维护，后来微视也凉了，这块业务也交出去了，然后主要是腾讯视频二创这个业务，就是鹅剪这边开发的剪辑工具打包成sdk提供给到腾讯视频这边，以支持视频创作者进行IP素材的二创，然后我这边也是围绕者视频二创的项目做一些上层业务的开发，比如说素材库、视频的合拍和跟拍

开放性问题
- 你对自己有什么规划 
1. 就是希望自己能够继续成长吧，因为目前自我感觉距离高级工程师还有一点差距，项目的经验 接触的东西、以及深度还不够 
2. 为了达成这样一个目标，就是保持长期进行技术学习的一个习惯，不限于新的技术，比如说compose、kmm，可以趁着新技术的发展深入地学习一波，随着技术的发展，自己也能积累到不错的东西，例如一些通用的知识或者解决方案；
3. 其次还包括一些经典框架的源码分析、基础架构、框架层面的架构能力；
4. 然后是持续学习基础方面的知识，比如操作系统、Linux的一些知识还需要不断地修炼；
5. 最后就是需要保持blog的输出和沉淀
- 最近在关注什么新的技术， 最近关注的是nowinandroid这个项目 compose kmm
- 有没有做过一下性能优化的例子，展开讲讲 
 有做过，只是做的东西比较小；比如说我们这边有个需求是需要在请求头里面携带上我们所使用的底层渲染库的版本以及所支持的能力的版本号，以便后台可以下发合适的素材，light、pag，一开始是直接使用的这些库提供的native接口去获取，如果这些库so没有load，则会先去load，虽说这样一看是没什么问题；但是后面发现会影响到App的冷启动，导致耗时会增加100ms，后续做的一个优化是将这些库的版本号写在gralde文件里面，然后可以通过BuildConfig去读取，这样读取就不会存在什么耗时了；虽然说这样存在弊端，就是人为去更新这些版本可能会存在问题，比如说忘记更新了或者更新错了，所以又补充了一个先从网络获取配置的逻辑，如果能正常读取到则用后台配置的，否则用本地的，这样就为了防止本地配置错误加了一个兜底的逻辑
- 如果加入隐私合规，你觉得会给隐私合规团队带来什么 我想知道如果我加入隐私合规，会让我承担一个怎么样的角色或者说我会负责哪方面的东西？虽然说项目的方向对我来说是一个比较新的东西，但是我想以我的学习能力与热情，我会随着项目快速成长起来，能够承担更重要的角色，同时会保证项目的交付质量以及代码的质量
（首先先明确自己需要在团队内承担一个怎么样的角色，是需要反问的。其次再表明自己的决心，以及对工作的热爱，无非就是保证需求、项目交付的质量，虽然说对自己可能是一个比较新的东西，但也要表明要把它吃透的决心，而且希望自己能够快速成长起来，能够承担更重要的角色）
