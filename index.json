[{"content":"简介 MVI 与 MVVM 比较相似，其借鉴了前端框架的思想，着重强调数据的单向流动和唯一数据源\n优势 强调数据单向流动，很容易对状态变化进行跟踪和回溯 使用ViewState对State集中管理，只需要订阅一个 ViewState 便可获取页面的所有状态，相对 MVVM 减少了不少模板代码 View通过ViewAction与ViewModel进行通信，又通过StateAction以触发State的变化 问题 当页面复杂，State容易膨胀 最佳实践 以页面为维度定义State，并且注意State中数据的定义，切勿数据裸在State里面 例如一个按钮的状态可能对应State中的数个字段，可进行包裹为ButtonState放置在State。\n当State复杂起来\n案例 收藏逻辑 我要收藏一个视频，UI发送一个事件到ViewModel，ViewModel调用Repository触发我们的收藏请求。 收藏请求回来需要展示一个Toast，提示用户收藏成功或者失败，这就以为着我们的ViewModel处理请求结果后，触发State变化，也就是我们CollectButtonSetate的变化。除此之外，还要想办法通知UI显示一条Toast。\n如果存储一个字段用于标识UI需要显示的Toast，UI collect到该状态时候会显示该Toast，但如果切后台再返回，UI又会显示该Toast了，因为我们的State是StateFlow承载的，\n新手引导 用户打开一个页面，需要一次显示2个引导浮窗。\n如果是在MVI的架构下，做这个逻辑；判断是否显示新手引导的逻辑得再逻辑层，即ViewModel层；\n使用误区 如图，初次使用MVI的同学在该页面的State中定义了2个字段来描述引导浮窗的状态\n其中存在两个问题：\n使用2个字段来描述是丑陋的 使用可空类型来描述引导流程中的状态更是丑陋的 最佳实践：定义一个枚举类描述引导流程中的状态\n1 2 3 4 5 enum class GuideState{ NOTHING, SHOW_TITLE_GUIDE, SHOW_DIRECT_ITEM_GUIDE } 其次，我再看看UI层的逻辑 其实这个逻辑也是挺奇怪的，监听Title变化的地方，存在引导显示的逻辑；这就违背了我们的原则，View只需监听相对应的状态变化即可。\n其次，再看看这个ViewAction的具体执行逻辑，如图，通过判断是否需要显示来更新引导的状态。 所以第二个疑惑的点就是，引导的状态其实并不依赖于其他的UI上面的东西，和用户的操作无关，正如与用户的操作无关却发送一个ViewAction是不太合适的，其实只需要在列表数据加载成功后，通过接口查询当前是否展示引导 去更新引导的状态即可。\nOK，我们总结下如何在MVI架构添加业务逻辑：\n定义一个状态来描述这个元素 在UI层监听这个状态的变化做相应的逻辑 在合适的时机更改这个状态 规范 ViewAction定义：用户在UI层的输入，例如：点击、下拉刷新、上拉加载更多，ClickTitle、LoadMore、Refresh StateAction定义：触发状态改变的操作，例如：修改按钮状态的可见性，则可定义为 UpdateXXBtnVisibility State定义：以页面为单位描述该页面的UI状态 Store定义：以页面为单位存储当前页面的UI状态 用户的输入事件向下流动，UI状态向上流动 如果要dispatch一个Action，不要一个行为派发多个Action，一个行为对应一个Action；例如：如果我们定义了两个Action，依次dispatch，以完成一个操作；倘若后面某个Action的能力改变了，是否会影响到另外一个Action呢？ 待解决问题 页面初始化逻辑 目前页面数据的加载的触发由名为LoadTypeFlow的流驱动，而目前在UI层主动向ViewModel dispatch一个ViewAction以触发LoadTypeFlow的改变以触发页面数据拉取\n其实这种流向是不符合我们的规范的，用户只是打开了该页面并没有输入一个事件，实际上应该是可以做成在ViewModel初始化的时候去触发数据加载的。\n参考 Android官方-应用架构指南 Android官方-界面事件\n","permalink":"/posts/tech/mvi/","summary":"简介 MVI 与 MVVM 比较相似，其借鉴了前端框架的思想，着重强调数据的单向流动和唯一数据源 优势 强调数据单向流动，很容易对状态变化进行跟踪和回溯 使用Vie","title":"mvi"},{"content":"摩的 双月湾的出行很是不便，滴滴是无人接单的，于是晚上出去觅食只能暂且步行而去。\n天下着小雨，路上瞅见小巷里的几辆电动单车，心中不免一般欢喜，可以少走两步了。记得上一次骑电单车还是毕业那会，去衡阳看女朋友那会了，骑着一辆单人电单车，从工学院门口一路骑到市区的商圈，也不失一番乐趣。 扫码后才发现起步价贵得惊人，十元起步，已经快赶上打车了，况且路程也不过2公里，实属不划算，只能作罢，继续往前走去。\n不久一辆摩的从身旁经过，正纠结走路还是摩的，差不多走来三分之一的路程了，咬咬牙还是继续往前走吧！不过走了一会又开始后悔没叫下那辆摩的了，终究还是想坐摩的的，其一是饿得不行了，已过饭点2小时了；其二是这淅淅沥沥的雨，似乎很难停下，容易让人感到这路程的漫长。\n1+1糖水铺 等待女朋友化妆的间隙，上小红书翻翻看周边有什么好吃的，看到一帖子推荐一个吃糖水的地方，想来在深圳呆的两年多里也没找到一家地道的糖水铺，难道在这小小的惠东县能有，也是抱着一试的心态奔过去了。\n天落着小雨，打了个摩的，到了当地的菜市场，顺着地图正在街上寻着，打开手机看了看地图，地图分明显示就在身前，但却没见着所谓的店面，正疑惑时，女朋友一声，”诶，这不就是嘛！“。侧身一看，推车旁挂着的招牌上面分明写着几个大字“1+1老字号糖水”，原来没有门面啊，只是街边的一个摊位，带着两辆小推车。但思来想去，却又拥有门面固定的性质，因为地图上还标注了它呀！ 难怪在对面摊位买柠檬鸡爪时，还惊讶这个摊位为啥这么多人买，到底是卖啥的。\n看过招牌上的菜单，选了个莲子元肉，其实一时我也没想起来这是个啥，但后来又正中下怀。果然，缘，妙不可言。\n莲子元肉糖水，第一口就让我想再买一碗，第一口就让我回味到了几年前的那碗糖水，清甜微凉，我想糖水本应如此，在这淅淅沥沥的雨天，吃一口糖水也挺合适。\n一碗喝完，想想还是别再买了，令人欢喜的可并不只是那清甜，而是那许久尚未品尝的味道，生怕再吃一碗日后就没有这份回忆了。\n路边老人 记得小时候，还住在农村，看到载客中巴在远处的山路经过，听到一阵喇叭声，满心欢喜地跟着嘟——嘟——嘟。 看到路边老人，搬个小凳，坐在自家门口，淡然地看着人来车往，或许这一坐就是半天。\n一个正欣喜入世，一个已悄然出世。\n菜市场的果贩 喝完一碗糖水，吃下一碗潮汕汤粉后，已然十点，自当满意离去。\n沿着小街往回走，路边的店铺基本上打烊了，路过一家水果铺，摊位前的数个果盆中还分别泡着几块菠萝、奈李、芒果、桃子，至于为什么是泡在水里的，还心存疑惑，可以理解菠萝是可以泡在盐水里的，其他的就不应该呀，驻足一会，老板就开口，顺手递过来了一个塑料袋。\n","permalink":"/posts/life/%E5%8F%8C%E6%9C%88%E6%B9%BE%E6%B8%B8%E8%AE%B0/","summary":"摩的 双月湾的出行很是不便，滴滴是无人接单的，于是晚上出去觅食只能暂且步行而去。 天下着小雨，路上瞅见小巷里的几辆电动单车，心中不免一般欢喜，可","title":"双月湾游记"},{"content":"kotlin Android-Redux-Intro 协程 Coroutines : First things first\n如何优雅的取消协程 ？\nKotlin Coroutines(协程) 完全解析（三），封装异步回调、协程间关系及协程的取消 [译] 如何优雅的处理协程的异常？\n","permalink":"/posts/tech/%E4%B8%8D%E9%94%99%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/","summary":"kotlin Android-Redux-Intro 协程 Coroutines : First things first 如何优雅的取消协程 ？ Kotlin Coroutines(协程) 完全解析（三），封装异步回调、协程间关系及协程的取消 [译] 如何优雅的处理","title":"不错的技术文章"},{"content":"gradle.properties中定义变量 1 light_sdk_version = 2.2.5.14 build.gradle中使用 现在gradle中定义一个函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def getProperty(String filename, String propName) { def propsFile = rootProject.file(filename) if (propsFile.exists()) { def props = new Properties() props.load(new FileInputStream(propsFile)) if (props[propName] != null) { return props[propName] } else { print(\u0026#34;No such property \u0026#34; + propName + \u0026#34; in file \u0026#34; + filename) } } else { print(filename + \u0026#34; does not exist!\u0026#34;) } } 使用 1 lightsdk : \u0026#34;com.tencent.light-withoutso:lightsdk:${getProperty(\u0026#34;gradle.properties\u0026#34;, \u0026#34;light_sdk_version\u0026#34;)}\u0026#34; 代码中使用 在build.gradle中定义 1 2 3 defaultConfig { buildConfigField \u0026#34;String\u0026#34;, \u0026#34;LIGHT_SDK_VERSION\u0026#34;, \u0026#34;${light_sdk_version}\u0026#34; } 使用 1 BuildConfig.LIGHT_SDK_VERSION build.gradle中定义变量 1 2 3 4 5 6 ext { light_sdk_version = \u0026#34;2.2.5.14\u0026#34; light_sdk_component_level = \u0026#34;78\u0026#34; pag_sdk_version = \u0026#34;3.3.0.138\u0026#34; pag_sdk_tag_level=\u0026#34;3\u0026#34; } build.gradle中使用 1 2 3 defaultConfig { buildConfigField \u0026#34;String\u0026#34;, \u0026#34;LIGHT_SDK_VERSION\u0026#34;, \u0026#34;\\\u0026#34;${project.light_sdk_version}\\\u0026#34;\u0026#34; } 代码中使用 在build.gradle中定义 1 2 3 defaultConfig { buildConfigField \u0026#34;String\u0026#34;, \u0026#34;LIGHT_SDK_VERSION\u0026#34;, \u0026#34;\\\u0026#34;${project.light_sdk_version}\\\u0026#34;\u0026#34; } 使用 1 BuildConfig.LIGHT_SDK_VERSION ","permalink":"/posts/tech/gradle.properties%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F/","summary":"gradle.properties中定义变量 1 light_sdk_version = 2.2.5.14 build.gradle中使用 现在gradle中定义一个函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14","title":"gradle.properties中定义变量"},{"content":"零食 百草味 商品名 推荐指数 满300-200 价格 菠萝干 100g ★★★★ 25.50 ￥8.73 泡椒凤爪 160g ★★★★★ 26.90 ￥9.21 脆冬枣 35g ★★★ 10.90 ￥3.73 椰丝球 210g ★★★ 32.50 ￥11.13 夏威夷果 100g ★★★★ 29.50 ￥10.11 猪肉脯（白芝麻味） 100g ★★★★ 29.50 ￥10.11 手撕鱿鱼条 80g ★★★★ 32.50 ￥11.13 一字豆干（五香味） 200g ★★★ 25.90 ￥8.87 卤鹌鹑蛋（五香味） 135g ★★★★ 26.90 ￥9.21 牛肉条 50g ★★★★ 32.50 ￥11.13 碧根果仁 56g ★★★★★ 31.50 ￥10.78 麻辣植物牛肉 100g ★★★★★ 25.90 ￥8.60 满300减200 买了12包共104.10元，谁知过不到几天，就有满300减210的活动了（这个应该是最划算的了）\n","permalink":"/posts/life/%E4%B8%80%E4%BA%9B%E9%9B%B6%E9%A3%9F%E6%8E%A8%E8%8D%90/","summary":"零食 百草味 商品名 推荐指数 满300-200 价格 菠萝干 100g ★★★★ 25.50 ￥8.73 泡椒凤爪 160g ★★★★★ 26.90 ￥9.21 脆冬枣 35g ★★★ 10.90 ￥3.73 椰丝球 210g ★","title":"一些零食推荐"},{"content":"源于最近需要换眼镜，因此做了下功课。\n防蓝光非球面镜片\n其实现在镜片都会带有防蓝光的属性，但是这个会更好一些，不过会造成镜片偏黄，透光度下降。生活中有害蓝光大都来自于电屏幕，可能用眼久了，多起来走走看看远方效果会更好一点，所以不考虑这种镜片。\n折射率 阿贝数 价格 1.70 71L 37 688送镜架（淘宝） 1.67 67L 32 455送镜架（淘宝） 1.60 60L Pro 40 不考虑 1.60 60L 33 不考虑 PMC非球面镜片\nPMC是一个新的材料，这种镜片透光度是98%相对于普通镜片（93%~95%）好一些，戴起来效果会更好一点，相对来说价格也更贵。\n折射率 阿贝数 价格 1.70 71L 37 751送镜架（淘宝） 1.60 60KP 40 378送镜架（淘宝） 1.71非球面镜片\n对于500°以上的近视患者，相对来说会选择折射率高的镜片，折射率越高镜片可以做得越薄，但是不能一味追求轻薄，因为镜片有一个阿贝尔指数，这个指数和折射率成反比，阿贝尔数越高镜片成像越清晰。\n型号 阿贝数 价格 71L 37 KR树脂、蓝光防护膜 688送镜架（淘宝） 71KP 37 PMC超亮、天视A6膜 751送镜架（淘宝） 71AS 37 KR树脂、明视复合膜 598送镜架（淘宝） 明视复合膜又称绿膜，天视A6膜又称蓝膜，蓝膜相对绿膜防油污容易清洁\n","permalink":"/posts/life/%E6%98%8E%E6%9C%88%E7%9C%BC%E9%95%9C%E5%AF%B9%E6%AF%94/","summary":"源于最近需要换眼镜，因此做了下功课。 防蓝光非球面镜片 其实现在镜片都会带有防蓝光的属性，但是这个会更好一些，不过会造成镜片偏黄，透光度下降。生","title":"明月眼镜对比"},{"content":"视频加滤镜播放 MediaCodec解码——\u0026gt;OpenGL es——\u0026gt; GLSurfaceView\n视频滤镜合成导出 MediaCodec解码——\u0026gt;OpenGL es——\u0026gt; MediaCodec编码 大体来说就是OpenGL渲染后的输出不一样，需要使用编码器编码保存到本地，由于OpenGL ES并不负责窗口管理以及上下文管理，该职责由各个平台自行完成，没有了GLSurfaceView为我们创建的上下文环境，因此我们需要使用相关的API初始化OpenGL的上下文环境以支持后续的操作。\n主要流程还是上图所示，该功能的实现，需要对整体的流程有一定的了解同时也需要掌握MediaCodec的使用以及需要注意一些坑，否则可能会导致视频无法播放。\n注意 MediaMuxer写完数据需要手动停止并释放资源，否则写的视频文件没有文件尾会导致不能播放。同理解码器和编码器在用完以后也需要释放。 一个线程对应一个OpenGL es 上下文，因此我们需要初始化俩个上下文环境，一个用于OpenGL着色器、顶点数据等渲染配置的初始化，一个用于在编解码线程中渲染。编解码线程中的上下文需要设置与OpenGL的初始化的线程共享上下文资源，包括纹理、FrameBuffer以及其他的Buffer等资源。 渲染一次完成后，需要切换一次egl的frame buffer，EGL的工作模式是双缓存模式，内部拥有俩个frame buffer（fb），当EGL将一个fb渲染到屏幕上的时候，另一个就在后台等待OpenGL进行交换。 1 EGL14.eglSwapBuffers(mEglDisplay, mEglSurfaceEncoder); ","permalink":"/posts/tech/opengl-es%E8%A7%86%E9%A2%91%E5%8A%A0%E6%BB%A4%E9%95%9C%E5%90%8E%E5%AF%BC%E5%87%BA/","summary":"视频加滤镜播放 MediaCodec解码——\u0026gt;OpenGL es——\u0026gt; GLSurfaceView 视频滤镜合成导出 MediaCodec解码——\u0026gt;Open","title":"OpenGL ES：视频加滤镜后导出"},{"content":"注意点 MediaCodec 解码后的原始数据，格式为yuv，而OpenGL所能渲染的格式为rgb，因此我们需要使用扩展库中的扩展纹理\nGLES11Ext.GL_TEXTURE_EXTERNAL_OES\n而它的作用就是实现YUV格式到RGB的自动转化。\n片段着色器中需使用扩展采样器：\nuniform samplerExternalOES sTexture COLOR_FormatYUV420Flexible YUV420Flexible并不是一种确定的YUV420格式，而是包含COLOR_FormatYUV411Planar, COLOR_FormatYUV411PackedPlanar, COLOR_FormatYUV420Planar, COLOR_FormatYUV420PackedPlanar, COLOR_FormatYUV420SemiPlanar和COLOR_FormatYUV420PackedSemiPlanar。在API 21引入YUV420Flexible的同时，它所包含的这些格式都deprecated掉了。\n那么为什么所有的解码器都支持YUV420Flexible呢？官方没有说明这点，但我猜测，只要解码器支持YUV420Flexible中的任意一种格式，就会被认为支持YUV420Flexible格式。也就是说，几乎所有的解码器都支持YUV420Flexible代表的格式中的一种或几种。\n此处引用： https://www.polarxiong.com/archives/Android-MediaCodec视频文件硬件解码-高效率得到YUV格式帧-快速保存JPEG图片-不使用OpenGL.html\n原理步骤： 生成一个oes纹理，并且以此得到一个SurfaceTexture，并设置帧可用回调监听，可用时请求渲染，再得到一个 Surface，并将它回调给外部MediaCodec 配置并启动解码器。（在ESL上下文环境中生成，因此需要通过回调给外部使用） 渲染完一帧后，需调用 surfaceTexture.updateTexImage() //更新纹理数据 onFrameAvailable可用时，请求GLSurfaceView渲染重绘即可 解码器 MediaCodec的准备：\n使用MediaExtract选择相应的视频/音频轨道，获取相应的格式信息（MediaFormat）。 使用MdiaCodec的类接口创建codec对象，配置音视频格式以及surface。（ OpenGL回调出来的 Surface surface = new Surface(surfaceTexture);） 启动解码器。 启动一个线程，循环从MediaExtract读取媒体文件数据到MdiaCodec的输入缓冲区，直至文件尾。 从MdiaCodec中取出被成功解码的buffer的 index 和 buffer的信息。index无误则把此buffer渲染到surface上去。 MediaCodec代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 package com.example.myapplication.ui.video; import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaExtractor; import android.media.MediaFormat; import android.util.Log; import android.view.Surface; import java.io.IOException; import java.nio.ByteBuffer; public class VideoCodec { private static final long TIMEOUT_USEC = 10000; private String TAG = \u0026#34;VideoCodec\u0026#34;; private MediaCodec videoDecoder; private MediaExtractor mediaExtractor; private boolean isAvailable = false; //视频路径 private String path; //OpenGL回调出来的 Surface Surface surface = new Surface(surfaceTexture); //surfaceTexture设置帧可用监听 //用于解码后数据的输出，交给OpenGL渲染 private Surface surface; public VideoCodec(String path,Surface surface) { mediaExtractor = new MediaExtractor(); this.path = path; this.surface = surface; } //传入指定的视频或音频格式，例如：video/、audio/ //返回当前格式轨道的index public int getTrackIndex(String mime) { int trackCount = mediaExtractor.getTrackCount(); int videoIndex=-1; for (int i = 0; i \u0026lt; trackCount; i++) { MediaFormat format = mediaExtractor.getTrackFormat(i); if (format.getString(MediaFormat.KEY_MIME).startsWith(mime)) { videoIndex = i; break; } } return videoIndex; } private boolean isPlaying = false; public void start(){ isPlaying = true; DecoderMP4Thread thread = new DecoderMP4Thread(); thread.start(); } //视频的解码放到子线程中进行，防止阻塞主线程 private class DecoderMP4Thread extends Thread { @Override public void run() { try { //首先设置待解码文件的路径 mediaExtractor.setDataSource(path); int videoIndex = getTrackIndex(\u0026#34;video/\u0026#34;); //当前index无效则直接退出 if (videoIndex \u0026lt; 0) { return; } //选取当前轨道 mediaExtractor.selectTrack(videoIndex); //获取视频的格式信息 MediaFormat mediaFormat = mediaExtractor.getTrackFormat(videoIndex); //设置解码支持的格式 mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatRGBFlexible); String mime = mediaFormat.getString(MediaFormat.KEY_MIME); //通过MIME创建解码器 videoDecoder = MediaCodec.createDecoderByType(mime); //配置 videoDecoder.configure(mediaFormat, surface, null, 0); } catch (IOException e) { e.printStackTrace(); } //启动解码器 videoDecoder.start(); int frameIndex = 0; boolean isVideoOver = false; // 开始循环，一直到视频资源结束 MediaCodec.BufferInfo videoBufferInfo = new MediaCodec.BufferInfo(); // 开始的时间 long startMs = System.currentTimeMillis(); // 当前Thread 没有被中断 while (!Thread.interrupted()) { if (!isPlaying) { continue; } if (!isVideoOver) { // 视频没有结束 提取一个单位的视频资源放到 解码器(mediaCodec) 缓冲区中 isVideoOver = putBufferToMediaCodec(mediaExtractor, videoDecoder); } // 返回一个被成功解码的buffer的 index 或者是一个信息 同时更新 videoBufferInfo 的数据 int outputBufferIndex = videoDecoder.dequeueOutputBuffer(videoBufferInfo, TIMEOUT_USEC); switch (outputBufferIndex) { case MediaCodec.INFO_OUTPUT_FORMAT_CHANGED: Log.v(TAG, \u0026#34;format changed\u0026#34;); break; case MediaCodec.INFO_TRY_AGAIN_LATER: Log.v(TAG, \u0026#34;超时\u0026#34;); break; case MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED: //outputBuffers = videoCodec.getOutputBuffers(); Log.v(TAG, \u0026#34;output buffers changed\u0026#34;); break; default: //延时操作 //如果缓冲区里的可展示时间\u0026gt;当前视频播放的总时间，就休眠一下 展示当前的帧， sleepRender(videoBufferInfo, startMs); //渲染为true就会渲染到surface configure() 设置的surface videoDecoder.releaseOutputBuffer(outputBufferIndex, true); frameIndex ++; Log.v(TAG, \u0026#34;frameIndex \u0026#34; + frameIndex); break; } if ((videoBufferInfo.flags \u0026amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) { Log.v(TAG, \u0026#34;buffer stream end\u0026#34;); break; } } //释放资源 videoDecoder.stop(); videoDecoder.release(); mediaExtractor.release(); } } /** * 将缓冲区传递至解码器 * 如果到了文件末尾，返回true;否则返回false */ private boolean putBufferToMediaCodec(MediaExtractor extractor, MediaCodec decoder) { boolean isMediaEOS = false; // 解码器 要填充有效数据的输入缓冲区的索引 —————— 此id的缓冲区可以被使用 int inputBufferIndex = decoder.dequeueInputBuffer(TIMEOUT_USEC); if (inputBufferIndex \u0026gt;= 0) { ByteBuffer inputBuffer = decoder.getInputBuffer(inputBufferIndex); // MediaExtractor读取媒体文件的数据，存储到缓冲区中。并返回大小。结束为-1 int sampleSize = extractor.readSampleData(inputBuffer, 0); if (sampleSize \u0026lt; 0) { decoder.queueInputBuffer(inputBufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM); isMediaEOS = true; Log.v(TAG, \u0026#34;media eos\u0026#34;); } else { // 在输入缓冲区添加数据之后，把它告诉 MediaCodec （解码） decoder.queueInputBuffer(inputBufferIndex, 0, sampleSize, extractor.getSampleTime(), 0); // MediaExtractor 准备下一个 单位的数据 extractor.advance(); } } return isMediaEOS; } private void sleepRender(MediaCodec.BufferInfo audioBufferInfo, long startMs) { // 这里的时间是 毫秒 presentationTimeUs 的时间是累加的 以微秒进行一帧一帧的累加 // audioBufferInfo 是改变的 while (audioBufferInfo.presentationTimeUs / 1000 \u0026gt; System.currentTimeMillis() - startMs) { try { // 10 毫秒 Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); break; } } } } 滤镜类（BaseFilter） ","permalink":"/posts/tech/opengl-es%E9%85%8D%E5%90%88mediacodec%E7%A1%AC%E8%A7%A3%E7%A0%81%E6%B8%B2%E6%9F%93%E8%A7%86%E9%A2%91%E5%8A%A0%E6%BB%A4%E9%95%9C%E6%92%AD%E6%94%BE/","summary":"注意点 MediaCodec 解码后的原始数据，格式为yuv，而OpenGL所能渲染的格式为rgb，因此我们需要使用扩展库中的扩展纹理 GLES11Ext.GL_TEXTURE_EXTERNAL_OES 而它的作用就是实现YUV格","title":"OpenGL ES：配合MediaCodec硬解码渲染（视频加滤镜播放）"}]