[{"content":"简介 MVI 与 MVVM 比较相似，其借鉴了前端框架的思想，着重强调数据的单向流动和唯一数据源\n优势  强调数据单向流动，很容易对状态变化进行跟踪和回溯 使用ViewState对State集中管理，只需要订阅一个 ViewState 便可获取页面的所有状态，相对 MVVM 减少了不少模板代码 View通过ViewAction与ViewModel进行通信，又通过StateAction以触发State的变化  问题  当页面复杂，State容易膨胀  最佳实践 以页面为维度定义State，并且注意State中数据的定义，切勿数据裸在State里面 例如一个按钮的状态可能对应State中的数个字段，可进行包裹为ButtonState放置在State。\n当State复杂起来\n 案例 收藏逻辑 我要收藏一个视频，UI发送一个事件到ViewModel，ViewModel调用Repository触发我们的收藏请求。 收藏请求回来需要展示一个Toast，提示用户收藏成功或者失败，这就以为着我们的ViewModel处理请求结果后，触发State变化，也就是我们CollectButtonSetate的变化。除此之外，还要想办法通知UI显示一条Toast。\n如果存储一个字段用于标识UI需要显示的Toast，UI collect到该状态时候会显示该Toast，但如果切后台再返回，UI又会显示该Toast了，因为我们的State是StateFlow承载的，\n新手引导 用户打开一个页面，需要一次显示2个引导浮窗。\n如果是在MVI的架构下，做这个逻辑；判断是否显示新手引导的逻辑得再逻辑层，即ViewModel层；\n使用误区 如图，初次使用MVI的同学在该页面的State中定义了2个字段来描述引导浮窗的状态\n其中存在两个问题：\n 使用2个字段来描述是丑陋的 使用可空类型来描述引导流程中的状态更是丑陋的  最佳实践：定义一个枚举类描述引导流程中的状态\n1 2 3 4 5  enum class GuideState{ NOTHING, SHOW_TITLE_GUIDE, SHOW_DIRECT_ITEM_GUIDE }   其次，我再看看UI层的逻辑 其实这个逻辑也是挺奇怪的，监听Title变化的地方，存在引导显示的逻辑；这就违背了我们的原则，View只需监听相对应的状态变化即可。\n其次，再看看这个ViewAction的具体执行逻辑，如图，通过判断是否需要显示来更新引导的状态。 所以第二个疑惑的点就是，引导的状态其实并不依赖于其他的UI上面的东西，和用户的操作无关，正如与用户的操作无关却发送一个ViewAction是不太合适的，其实只需要在列表数据加载成功后，通过接口查询当前是否展示引导 去更新引导的状态即可。\nOK，我们总结下如何在MVI架构添加业务逻辑：\n 定义一个状态来描述这个元素 在UI层监听这个状态的变化做相应的逻辑 在合适的时机更改这个状态  规范  ViewAction定义：用户在UI层的输入，例如：点击、下拉刷新、上拉加载更多，ClickTitle、LoadMore、Refresh StateAction定义：触发状态改变的操作，例如：修改按钮状态的可见性，则可定义为 UpdateXXBtnVisibility State定义：以页面为单位描述该页面的UI状态 Store定义：以页面为单位存储当前页面的UI状态 用户的输入事件向下流动，UI状态向上流动 如果要dispatch一个Action，不要一个行为派发多个Action，一个行为对应一个Action；例如：如果我们定义了两个Action，依次dispatch，以完成一个操作；倘若后面某个Action的能力改变了，是否会影响到另外一个Action呢？  待解决问题 页面初始化逻辑 目前页面数据的加载的触发由名为LoadTypeFlow的流驱动，而目前在UI层主动向ViewModel dispatch一个ViewAction以触发LoadTypeFlow的改变以触发页面数据拉取\n其实这种流向是不符合我们的规范的，用户只是打开了该页面并没有输入一个事件，实际上应该是可以做成在ViewModel初始化的时候去触发数据加载的。\n参考 Android官方-应用架构指南 Android官方-界面事件\n","permalink":"/posts/tech/mvi/","summary":"简介 MVI 与 MVVM 比较相似，其借鉴了前端框架的思想，着重强调数据的单向流动和唯一数据源 优势 强调数据单向流动，很容易对状态变化进行跟踪和回溯 使用Vie","title":"mvi"},{"content":"摩的 双月湾的出行很是不便，滴滴是无人接单的，于是晚上出去觅食只能暂且步行而去。\n天下着小雨，路上瞅见小巷里的几辆电动单车，心中不免一般欢喜，可以少走两步了。记得上一次骑电单车还是毕业那会，去衡阳看女朋友那会了，骑着一辆单人电单车，从工学院门口一路骑到市区的商圈，也不失一番乐趣。 扫码后才发现起步价贵得惊人，十元起步，已经快赶上打车了，况且路程也不过2公里，实属不划算，只能作罢，继续往前走去。\n不久一辆摩的从身旁经过，正纠结走路还是摩的，差不多走来三分之一的路程了，咬咬牙还是继续往前走吧！不过走了一会又开始后悔没叫下那辆摩的了，终究还是想坐摩的的，其一是饿得不行了，已过饭点2小时了；其二是这淅淅沥沥的雨，似乎很难停下，容易让人感到这路程的漫长。\n一番纠结过后，还是决定叫下一辆摩的，起初一辆摩的叫价属实颇高，2公里的路居然还要20元，也不愿意被回价，我们只能望着他的背影扬长而去。\n1+1糖水铺 等待女朋友化妆的间隙，上小红书翻翻看周边有什么好吃的，看到一帖子推荐一个吃糖水的地方，想来在深圳呆的两年多里也没找到一家地道的糖水铺，难道在这小小的惠东县能有，也是抱着一试的心态奔过去了。\n天落着小雨，打了个摩的，到了当地的菜市场，顺着地图正在街上寻着，打开手机看了看地图，地图分明显示就在身前，但却没见着所谓的店面，正疑惑时，女朋友一声，”诶，这不就是嘛！“。侧身一看，推车旁挂着的招牌上面分明写着几个大字“1+1老字号糖水”，原来没有门面啊，只是街边的一个摊位，带着两辆小推车。但思来想去，却又拥有门面固定的性质，因为地图上还标注了它呀！ 难怪在对面摊位买柠檬鸡爪时，还惊讶这个摊位为啥这么多人买，到底是卖啥的。\n看过招牌上的菜单，选了个莲子元肉，其实一时我也没想起来这是个啥，但后来又正中下怀。果然，缘，妙不可言。\n莲子元肉糖水，第一口就让我想再买一碗，第一口就让我回味到了几年前的那碗糖水，清甜微凉，我想糖水本应如此，在这淅淅沥沥的雨天，吃一口糖水也挺合适。\n一碗喝完，想想还是别再买了，令人欢喜的可并不只是那清甜，而是那许久尚未品尝的味道，生怕再吃一碗日后就没有这份回忆了。\n路边老人 记得小时候，还住在农村，看到载客中巴在远处的山路经过，听到一阵喇叭声，满心欢喜地跟着嘟——嘟——嘟。 看到路边老人，搬个小凳，坐在自家门口，淡然地看着人来车往，或许这一坐就是半天。\n一个正欣喜入世，一个已悄然出世。\n菜市场的果贩 喝完一碗糖水，吃下一碗潮汕汤粉后，已然十点，自当满意离去。\n沿着小街往回走，路边的店铺基本上打烊了，路过一家水果铺，摊位前的数个果盆中还分别泡着几块菠萝、奈李、芒果、桃子，至于为什么是泡在水里的，还心存疑惑，可以理解菠萝是可以泡在盐水里的，其他的就不应该呀，驻足一会，老板就开口，顺手递过来了一个塑料袋。\n","permalink":"/posts/life/%E5%8F%8C%E6%9C%88%E6%B9%BE%E6%B8%B8%E8%AE%B0/","summary":"摩的 双月湾的出行很是不便，滴滴是无人接单的，于是晚上出去觅食只能暂且步行而去。 天下着小雨，路上瞅见小巷里的几辆电动单车，心中不免一般欢喜，可","title":"双月湾游记"},{"content":"kotlin  Android-Redux-Intro  协程   Coroutines : First things first\n  如何优雅的取消协程 ？\n  Kotlin Coroutines(协程) 完全解析（三），封装异步回调、协程间关系及协程的取消 \n  [译] 如何优雅的处理协程的异常？\n  ","permalink":"/posts/tech/%E4%B8%8D%E9%94%99%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/","summary":"kotlin Android-Redux-Intro 协程 Coroutines : First things first 如何优雅的取消协程 ？ Kotlin Coroutines(协程) 完全解析（三），封装异步回调、协程间关系及协程的取消 [译] 如何优雅的处理","title":"不错的技术文章"},{"content":"gradle.properties中定义变量 1  light_sdk_version = 2.2.5.14   build.gradle中使用  现在gradle中定义一个函数  1 2 3 4 5 6 7 8 9 10 11 12 13 14  def getProperty(String filename, String propName) { def propsFile = rootProject.file(filename) if (propsFile.exists()) { def props = new Properties() props.load(new FileInputStream(propsFile)) if (props[propName] != null) { return props[propName] } else { print(\u0026#34;No such property \u0026#34; + propName + \u0026#34; in file \u0026#34; + filename) } } else { print(filename + \u0026#34; does not exist!\u0026#34;) } }   使用  1  lightsdk : \u0026#34;com.tencent.light-withoutso:lightsdk:${getProperty(\u0026#34;gradle.properties\u0026#34;, \u0026#34;light_sdk_version\u0026#34;)}\u0026#34;   代码中使用  在build.gradle中定义  1 2 3  defaultConfig { buildConfigField \u0026#34;String\u0026#34;, \u0026#34;LIGHT_SDK_VERSION\u0026#34;, \u0026#34;${light_sdk_version}\u0026#34; }   使用  1  BuildConfig.LIGHT_SDK_VERSION   build.gradle中定义变量 1 2 3 4 5 6  ext { light_sdk_version = \u0026#34;2.2.5.14\u0026#34; light_sdk_component_level = \u0026#34;78\u0026#34; pag_sdk_version = \u0026#34;3.3.0.138\u0026#34; pag_sdk_tag_level=\u0026#34;3\u0026#34; }   build.gradle中使用 1 2 3  defaultConfig { buildConfigField \u0026#34;String\u0026#34;, \u0026#34;LIGHT_SDK_VERSION\u0026#34;, \u0026#34;\\\u0026#34;${project.light_sdk_version}\\\u0026#34;\u0026#34; }   代码中使用  在build.gradle中定义  1 2 3  defaultConfig { buildConfigField \u0026#34;String\u0026#34;, \u0026#34;LIGHT_SDK_VERSION\u0026#34;, \u0026#34;\\\u0026#34;${project.light_sdk_version}\\\u0026#34;\u0026#34; }   使用  1  BuildConfig.LIGHT_SDK_VERSION   ","permalink":"/posts/tech/gradle.properties%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F/","summary":"gradle.properties中定义变量 1 light_sdk_version = 2.2.5.14 build.gradle中使用 现在gradle中定义一个函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14","title":"gradle.properties中定义变量"},{"content":"零食 百草味    商品名 推荐指数 满300-200 价格     菠萝干 100g ★★★★ 25.50 ￥8.73   泡椒凤爪 160g ★★★★★ 26.90 ￥9.21   脆冬枣 35g ★★★ 10.90 ￥3.73   椰丝球 210g ★★★ 32.50 ￥11.13   夏威夷果 100g ★★★★ 29.50 ￥10.11   猪肉脯（白芝麻味） 100g ★★★★ 29.50 ￥10.11   手撕鱿鱼条 80g ★★★★ 32.50 ￥11.13   一字豆干（五香味） 200g ★★★ 25.90 ￥8.87   卤鹌鹑蛋（五香味） 135g ★★★★ 26.90 ￥9.21   牛肉条 50g ★★★★ 32.50 ￥11.13   碧根果仁 56g ★★★★★ 31.50 ￥10.78   麻辣植物牛肉 100g ★★★★★ 25.90 ￥8.60    满300减200 买了12包共104.10元，谁知过不到几天，就有满300减210的活动了（这个应该是最划算的了）\n","permalink":"/posts/life/%E4%B8%80%E4%BA%9B%E9%9B%B6%E9%A3%9F%E6%8E%A8%E8%8D%90/","summary":"零食 百草味 商品名 推荐指数 满300-200 价格 菠萝干 100g ★★★★ 25.50 ￥8.73 泡椒凤爪 160g ★★★★★ 26.90 ￥9.21 脆冬枣 35g ★★★ 10.90 ￥3.73 椰丝球 210g ★","title":"一些零食推荐"},{"content":"源于最近需要换眼镜，因此做了下功课。\n防蓝光非球面镜片\n其实现在镜片都会带有防蓝光的属性，但是这个会更好一些，不过会造成镜片偏黄，透光度下降。生活中有害蓝光大都来自于电屏幕，可能用眼久了，多起来走走看看远方效果会更好一点，所以不考虑这种镜片。\n   折射率 阿贝数 价格     1.70 71L 37 688送镜架（淘宝）   1.67 67L 32 455送镜架（淘宝）   1.60 60L Pro 40 不考虑   1.60 60L 33 不考虑    PMC非球面镜片\nPMC是一个新的材料，这种镜片透光度是98%相对于普通镜片（93%~95%）好一些，戴起来效果会更好一点，相对来说价格也更贵。\n   折射率 阿贝数 价格     1.70 71L 37 751送镜架（淘宝）   1.60 60KP 40 378送镜架（淘宝）    1.71非球面镜片\n对于500°以上的近视患者，相对来说会选择折射率高的镜片，折射率越高镜片可以做得越薄，但是不能一味追求轻薄，因为镜片有一个阿贝尔指数，这个指数和折射率成反比，阿贝尔数越高镜片成像越清晰。\n   型号 阿贝数  价格     71L 37 KR树脂、蓝光防护膜 688送镜架（淘宝）   71KP 37 PMC超亮、天视A6膜 751送镜架（淘宝）   71AS 37 KR树脂、明视复合膜 598送镜架（淘宝）    明视复合膜又称绿膜，天视A6膜又称蓝膜，蓝膜相对绿膜防油污容易清洁\n","permalink":"/posts/life/%E6%98%8E%E6%9C%88%E7%9C%BC%E9%95%9C%E5%AF%B9%E6%AF%94/","summary":"源于最近需要换眼镜，因此做了下功课。 防蓝光非球面镜片 其实现在镜片都会带有防蓝光的属性，但是这个会更好一些，不过会造成镜片偏黄，透光度下降。生","title":"明月眼镜对比"},{"content":"18年末 年后便是大三，驾照也已到手，也没其余杂事。那可要准备面试，年后就得找暑期实习了。虽说离毕业还有两年，但学校里的课程是不能再学到可用的知识了，更应该投入到实际项目的开发中去，能对专业能力有很大的改进和提升，同时也是一段可贵的实习经验，加速自己各方面的成长。如果实习表现优秀，能得到leader的认可，通过转正拿到毕业生offer，后面一学年也就没什么压力可言，不过找到一份好的实习还是具有挑战性的。\n一同学年前就拿到了字节跳动的offer，可以说是非常优秀。能够领先这么多，想想看，他每天坚持学习，当然水到渠成，不足为奇。我与他的关系也仅限于点头之交，不好询问面试的诸多问题。当然字节跳动的offer对我的吸引力不亚于bat，极其羡慕。\n想买的技术书籍有好几本并且价格不菲（60+），倒不如买个Ipad看PDF版，也易于携带去上课。价格（2300）相对于穷学生来说还是比较昂贵，也不想让妈妈给我付账，想着过年的红包钱可以预支，再三纠结后还是分期买下了，当然Apple Pencil是还让妈妈付的，用于学习，也心安理得。\n善于投资自己，对自己有好处的东西，尽管去做吧，切勿因小失大\n复习 实验室Android部门上一任部长在字节跳动工作，年末实习离职了，可内推几位同学的简历（免笔试），由于当时的我还刚开始复习，并没有太大的把握去面试，但还是认真地制作了简历。但由于年前错过了内推的时间，因此也错失了这次机会，当时的自己依旧没有把握去应对这场面试，也就不了了之 。\n了解到另外一位同学也让学长内推了简历，但是一面直接没过，问的问题当中我自己也不能保证初次面试下有条理的说出来。\n当时也进入了复习的状态，日常翘课，上课也只带自己的Ipad去复习，日常刷牛客看面经，复习的日子就是这样有条不紊的进行着。\n 刷牛客网的Java基础题+剑指offer+八大排序 看牛客网面经 Android基础 Android开发者艺术探索 Android常用框架源码解析  复习不是学习，是需要知识储备的，知识储备又源于长期坚持学习\n面试 开始也投了些中小公司，对于BAT这种大企业依旧没有十足的把握。 随着准备得越来越充足，其中也面试了大大小小几家公司，当然充满遗憾和心酸，然而面试经验也越发丰富，到最后面试腾讯的时候也是十分顺利哈。\n凡事需要准备，准备越充足也会越自信，自然手到擒来\nCVTE 一面 第一次面试是CVTE的电话面，问的问题都比较常规，其中两个问题不会，不过也通过了。\nhr面 当时也比较开心，本以为可以首战告捷，也没有想到还有后来这么一些事情。当时在网上看了些这个公司的一些帖子，知乎上面大部分都是黑这家公司的，同时牛客网上面也了解到这家公司的hr面很多人被刷。不过的确也实际体验到了，也不足为奇。\n询问未来规划、理想、家长里短，性格缺陷等一系列私人问题，其实让你卸下心防，其次再问对薪资的要求、对加班的看法、工作地的想法。还是太年轻，不愿当舔狗，对薪资要求稍高又不想加班。事后想想，其实可以先拿到offer再说，没必要这么真实。\n见人说人话，见鬼说鬼话\n蘑菇街 一面 项目组内的一个小哥，面试很顺利，对我的印象很好，实在地夸赞了我一番。\n二面 组内的leader，项目难点和自定义View（如何实现一个列表下拉刷新控件）答得不好，就算其他问题回答得不错并且算法也秒了，但是还是很遗憾的得被刷了。其实也觉得项目难点不好回答，如今想想当时的回答的确很差劲，后面让自己实现自定义控件也慌了，应该好好思考，或许还能够得到提示，而不是直接说不知道。\n面试结束后的几天内，每隔几十分钟刷新一次蘑菇街招聘页面，最终还是收到了感谢信。记得当时连去了蘑菇街要做什么都想好了，终究情非得已。\n事情没有尘埃落定之前都不能掉以轻心\n网易 一个老大哥和一个小老哥一起视频面试的我，无语了都。\n拼多多 在图书馆的走廊座椅上被一位全栈大佬用微信视频面了两个小时，被问到怀疑人生也毫不为过，处境甚是窘迫，看到了自己很多不足，对于自身这种不服输、自尊心强的性格，难免会被问得面红耳赤。\n腾讯 牛客网面经\n面试官是湖南老乡（后来才知道是我的leader），面试过程很亲和，面试也就很自信，受到了面试官的青睐。\n厚积薄发\n初来乍到 安排好学校的代课事宜就立马逃脱了学校，和同学一起组队来到了深圳。\n入住了公司为实习生安排的中转酒店，同住的是一名研究生。\n第二天便去公司报道，领取了工卡、公仔，去了自己的工位，不过没有见到leader。\n由于酒店住宿洗衣服不方便，而且和陌生人同住，感觉不是那么愉快，便下午就去看房子。\n下午再过来的时候，遇见了我的leader和我的导师，在导师的帮助下安装好了iMac，初次见面当然是比较拘谨。\n租房 留用答辩 当然实习的时候也无不想过留用答辩的事情，毕竟如果能够顺利留用，对之后毕业的压力会减轻很多，不用再复习去秋招，不用担心毕业的事情等等，安心学习、好好生活就可以了。\n当然，更重要的是自己也愿意留下来。在我自己看来，短视频是未来生活的一部分，这点是毋容置疑的，短视频目前似乎在很多人的生活中代替了以往的媒体，成为了获取信息的重要来源之一。\n记得和我一起实习的女同学对我说过这样的一句话：你真的好稳啊，看起来做什么事都那么从容。可能是之前找实习的时候一起聊过天，那时候她已经拿到了Tencent的offer，而我一无所有，但是我的脸上也还能挂着一副笑容，从容不迫地和他们聊着，再结合如今我的工作态度以及对留用的看法才得出这样的一种结论。而我回了她一句范仲淹的《岳阳楼记》中的一句话：不以物喜，不以己悲。\n其实，担忧未来本是一件好事，但不需要过分担忧，更重要的是能够做好当前的事。目前实习的工作做好了，个人能力得到了领导的认可，工作成果得到领导的赞赏，这些事不正是作为留用的一个考核点。很多时候，当前的所作所为往往成就着将来，当然前提是目标明确\n同组还有一个华中科技大学的研究生，本科就读于厦门大学，可以说在学历背景上面已经甩我几条街了，同时年龄也比我大三岁，但是这也不能足以将我battel下去，终究还是得看个人能力。\n记得一起接受一个模块重构的需求，自己在团队协作以及解决问题的能力就很完美的体现出来，以致于导师都愿意和我交流，我们两个人当中把我当做这个需求的负责人。而又为什么使得别人信服我呢？总结了一下几点（Ta指代同组那位研究生）：\n 谦虚好问，善于沟通，及时同步开发进度以及遇见的困难并请教相应的同事；多次请教导师、同事问题，并一起讨论解决方案。相对来说，Ta就比较沉闷，很少去找导师或同事。 解决问题能力强；能够比较高效完成自己负责模块以及解决遇见的问题。相对来说，Ta开发效率比较低，甚至有些常见的问题都不知道如何解决。 团队意识；完成自己分配的需求后，又去关注其他人负责的模块，帮助同事解决问题（此条在个人能力强的基础上进行）。相对来说，Ta自己的模块的需求都不能高效完成，那就何谈帮助别人。  以至于答辩完成以后，leader也和我说了为什么留下了我：学历不代表学力，他在学历背景方面可以说甩你几条街，但是在学习能力方面你很厉害\n答辩不久后，同组实习生离职去准备秋招了，而我仍呆在鹅厂实习。期间也给我换了一个导师——一个大我4岁的老哥，后面也成为了我关系最好的同事，亦师亦友，给予了我很多帮助，总而言之还是很幸运的。\n尚未入职，leader跑了 后面部门进行组织架构调整，当前微视的业务换了一波人来接手，原leader带一批人去做底层能力的业务，当时leader也有找各位同事一一聊过去，可以说大部分人都想过去吧。可唯独没有找我聊，也许我只是一个实习生，并不能对他产生很大的价值，而名额又是有限的，那就很好理解了。还没正式入职就换leader了，感觉还是很不好的，毕竟换了一个新的leader，又得重新建立信任，展示自己的能力。\n记得，新来的leader有一一找我们谈话，那是一个战战兢兢，说话都很是拘谨，说话结结巴巴的，时而哆嗦，现在想来真是可笑呵！\n后面也就那样，组织架构的变化，对我也并未产生多大的影响，只是默默地搬砖，做好自己的工作，兢兢业业干到年底。那时疫情并不起眼，正慢慢袭来，临走前去企鹅医生买了两袋口罩以备路上之需。\n疫情之年，不串门的春节 回家以后，疫情迅速发展起来，爆发地——武汉市已做封城处理，城内有的人想出来，城外有的人想进去，境地不同，心志不同。远处十八线小县城，周围没有感染的病例，但每天看看全国感染新增人数也闹得人心惶惶，不敢出门，整个春节基本都在家里度过。就算想出门，也没有口罩可用，市面上的口罩早已销售一空，家里人的一个口罩也是用好久，以维持正常生活所需。\n","permalink":"/posts/life/2019%E5%B9%B4%E6%80%BB%E7%BB%93/","summary":"18年末 年后便是大三，驾照也已到手，也没其余杂事。那可要准备面试，年后就得找暑期实习了。虽说离毕业还有两年，但学校里的课程是不能再学到可用的","title":"2019年总结"},{"content":"视频加滤镜播放 MediaCodec解码——\u0026gt;OpenGL es——\u0026gt; GLSurfaceView\n视频滤镜合成导出 MediaCodec解码——\u0026gt;OpenGL es——\u0026gt; MediaCodec编码 大体来说就是OpenGL渲染后的输出不一样，需要使用编码器编码保存到本地，由于OpenGL ES并不负责窗口管理以及上下文管理，该职责由各个平台自行完成，没有了GLSurfaceView为我们创建的上下文环境，因此我们需要使用相关的API初始化OpenGL的上下文环境以支持后续的操作。\n主要流程还是上图所示，该功能的实现，需要对整体的流程有一定的了解同时也需要掌握MediaCodec的使用以及需要注意一些坑，否则可能会导致视频无法播放。\n注意  MediaMuxer写完数据需要手动停止并释放资源，否则写的视频文件没有文件尾会导致不能播放。同理解码器和编码器在用完以后也需要释放。 一个线程对应一个OpenGL es 上下文，因此我们需要初始化俩个上下文环境，一个用于OpenGL着色器、顶点数据等渲染配置的初始化，一个用于在编解码线程中渲染。编解码线程中的上下文需要设置与OpenGL的初始化的线程共享上下文资源，包括纹理、FrameBuffer以及其他的Buffer等资源。 渲染一次完成后，需要切换一次egl的frame buffer，EGL的工作模式是双缓存模式，内部拥有俩个frame buffer（fb），当EGL将一个fb渲染到屏幕上的时候，另一个就在后台等待OpenGL进行交换。  1  EGL14.eglSwapBuffers(mEglDisplay, mEglSurfaceEncoder);   ","permalink":"/posts/tech/opengl-es%E8%A7%86%E9%A2%91%E5%8A%A0%E6%BB%A4%E9%95%9C%E5%90%8E%E5%AF%BC%E5%87%BA/","summary":"视频加滤镜播放 MediaCodec解码——\u0026gt;OpenGL es——\u0026gt; GLSurfaceView 视频滤镜合成导出 MediaCodec解码——\u0026gt;Open","title":"OpenGL ES：视频加滤镜后导出"},{"content":"注意点   MediaCodec 解码后的原始数据，格式为yuv，而OpenGL所能渲染的格式为rgb，因此我们需要使用扩展库中的扩展纹理\nGLES11Ext.GL_TEXTURE_EXTERNAL_OES\n  而它的作用就是实现YUV格式到RGB的自动转化。\n片段着色器中需使用扩展采样器：\nuniform samplerExternalOES sTexture  COLOR_FormatYUV420Flexible  YUV420Flexible并不是一种确定的YUV420格式，而是包含COLOR_FormatYUV411Planar, COLOR_FormatYUV411PackedPlanar, COLOR_FormatYUV420Planar, COLOR_FormatYUV420PackedPlanar, COLOR_FormatYUV420SemiPlanar和COLOR_FormatYUV420PackedSemiPlanar。在API 21引入YUV420Flexible的同时，它所包含的这些格式都deprecated掉了。\n那么为什么所有的解码器都支持YUV420Flexible呢？官方没有说明这点，但我猜测，只要解码器支持YUV420Flexible中的任意一种格式，就会被认为支持YUV420Flexible格式。也就是说，几乎所有的解码器都支持YUV420Flexible代表的格式中的一种或几种。\n此处引用： https://www.polarxiong.com/archives/Android-MediaCodec视频文件硬件解码-高效率得到YUV格式帧-快速保存JPEG图片-不使用OpenGL.html\n原理步骤：  生成一个oes纹理，并且以此得到一个SurfaceTexture，并设置帧可用回调监听，可用时请求渲染，再得到一个 Surface，并将它回调给外部MediaCodec 配置并启动解码器。（在ESL上下文环境中生成，因此需要通过回调给外部使用） 渲染完一帧后，需调用 surfaceTexture.updateTexImage() //更新纹理数据 onFrameAvailable可用时，请求GLSurfaceView渲染重绘即可   解码器 MediaCodec的准备：\n 使用MediaExtract选择相应的视频/音频轨道，获取相应的格式信息（MediaFormat）。 使用MdiaCodec的类接口创建codec对象，配置音视频格式以及surface。（ OpenGL回调出来的 Surface surface = new Surface(surfaceTexture);） 启动解码器。 启动一个线程，循环从MediaExtract读取媒体文件数据到MdiaCodec的输入缓冲区，直至文件尾。 从MdiaCodec中取出被成功解码的buffer的 index 和 buffer的信息。index无误则把此buffer渲染到surface上去。  MediaCodec代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183  package com.example.myapplication.ui.video; import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaExtractor; import android.media.MediaFormat; import android.util.Log; import android.view.Surface; import java.io.IOException; import java.nio.ByteBuffer; public class VideoCodec { private static final long TIMEOUT_USEC = 10000; private String TAG = \u0026#34;VideoCodec\u0026#34;; private MediaCodec videoDecoder; private MediaExtractor mediaExtractor; private boolean isAvailable = false; //视频路径  private String path; //OpenGL回调出来的 Surface Surface surface = new Surface(surfaceTexture);  //surfaceTexture设置帧可用监听  //用于解码后数据的输出，交给OpenGL渲染  private Surface surface; public VideoCodec(String path,Surface surface) { mediaExtractor = new MediaExtractor(); this.path = path; this.surface = surface; } //传入指定的视频或音频格式，例如：video/、audio/ \t//返回当前格式轨道的index  public int getTrackIndex(String mime) { int trackCount = mediaExtractor.getTrackCount(); int videoIndex=-1; for (int i = 0; i \u0026lt; trackCount; i++) { MediaFormat format = mediaExtractor.getTrackFormat(i); if (format.getString(MediaFormat.KEY_MIME).startsWith(mime)) { videoIndex = i; break; } } return videoIndex; } private boolean isPlaying = false; public void start(){ isPlaying = true; DecoderMP4Thread thread = new DecoderMP4Thread(); thread.start(); } //视频的解码放到子线程中进行，防止阻塞主线程  private class DecoderMP4Thread extends Thread { @Override public void run() { try { //首先设置待解码文件的路径  mediaExtractor.setDataSource(path); int videoIndex = getTrackIndex(\u0026#34;video/\u0026#34;); //当前index无效则直接退出  if (videoIndex \u0026lt; 0) { return; } //选取当前轨道  mediaExtractor.selectTrack(videoIndex); //获取视频的格式信息  MediaFormat mediaFormat = mediaExtractor.getTrackFormat(videoIndex); //设置解码支持的格式  mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatRGBFlexible); String mime = mediaFormat.getString(MediaFormat.KEY_MIME); //通过MIME创建解码器  videoDecoder = MediaCodec.createDecoderByType(mime); //配置  videoDecoder.configure(mediaFormat, surface, null, 0); } catch (IOException e) { e.printStackTrace(); } //启动解码器  videoDecoder.start(); int frameIndex = 0; boolean isVideoOver = false; // 开始循环，一直到视频资源结束  MediaCodec.BufferInfo videoBufferInfo = new MediaCodec.BufferInfo(); // 开始的时间  long startMs = System.currentTimeMillis(); // 当前Thread 没有被中断  while (!Thread.interrupted()) { if (!isPlaying) { continue; } if (!isVideoOver) { // 视频没有结束 提取一个单位的视频资源放到 解码器(mediaCodec) 缓冲区中  isVideoOver = putBufferToMediaCodec(mediaExtractor, videoDecoder); } // 返回一个被成功解码的buffer的 index 或者是一个信息 同时更新 videoBufferInfo 的数据  int outputBufferIndex = videoDecoder.dequeueOutputBuffer(videoBufferInfo, TIMEOUT_USEC); switch (outputBufferIndex) { case MediaCodec.INFO_OUTPUT_FORMAT_CHANGED: Log.v(TAG, \u0026#34;format changed\u0026#34;); break; case MediaCodec.INFO_TRY_AGAIN_LATER: Log.v(TAG, \u0026#34;超时\u0026#34;); break; case MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED: //outputBuffers = videoCodec.getOutputBuffers();  Log.v(TAG, \u0026#34;output buffers changed\u0026#34;); break; default: //延时操作  //如果缓冲区里的可展示时间\u0026gt;当前视频播放的总时间，就休眠一下 展示当前的帧，  sleepRender(videoBufferInfo, startMs); //渲染为true就会渲染到surface configure() 设置的surface  videoDecoder.releaseOutputBuffer(outputBufferIndex, true); frameIndex ++; Log.v(TAG, \u0026#34;frameIndex \u0026#34; + frameIndex); break; } if ((videoBufferInfo.flags \u0026amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) { Log.v(TAG, \u0026#34;buffer stream end\u0026#34;); break; } } //释放资源  videoDecoder.stop(); videoDecoder.release(); mediaExtractor.release(); } } /** * 将缓冲区传递至解码器 * 如果到了文件末尾，返回true;否则返回false */ private boolean putBufferToMediaCodec(MediaExtractor extractor, MediaCodec decoder) { boolean isMediaEOS = false; // 解码器 要填充有效数据的输入缓冲区的索引 —————— 此id的缓冲区可以被使用  int inputBufferIndex = decoder.dequeueInputBuffer(TIMEOUT_USEC); if (inputBufferIndex \u0026gt;= 0) { ByteBuffer inputBuffer = decoder.getInputBuffer(inputBufferIndex); // MediaExtractor读取媒体文件的数据，存储到缓冲区中。并返回大小。结束为-1  int sampleSize = extractor.readSampleData(inputBuffer, 0); if (sampleSize \u0026lt; 0) { decoder.queueInputBuffer(inputBufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM); isMediaEOS = true; Log.v(TAG, \u0026#34;media eos\u0026#34;); } else { // 在输入缓冲区添加数据之后，把它告诉 MediaCodec （解码）  decoder.queueInputBuffer(inputBufferIndex, 0, sampleSize, extractor.getSampleTime(), 0); // MediaExtractor 准备下一个 单位的数据  extractor.advance(); } } return isMediaEOS; } private void sleepRender(MediaCodec.BufferInfo audioBufferInfo, long startMs) { // 这里的时间是 毫秒 presentationTimeUs 的时间是累加的 以微秒进行一帧一帧的累加  // audioBufferInfo 是改变的  while (audioBufferInfo.presentationTimeUs / 1000 \u0026gt; System.currentTimeMillis() - startMs) { try { // 10 毫秒  Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); break; } } } }   滤镜类（BaseFilter） ","permalink":"/posts/tech/opengl-es%E9%85%8D%E5%90%88mediacodec%E7%A1%AC%E8%A7%A3%E7%A0%81%E6%B8%B2%E6%9F%93%E8%A7%86%E9%A2%91%E5%8A%A0%E6%BB%A4%E9%95%9C%E6%92%AD%E6%94%BE/","summary":"注意点 MediaCodec 解码后的原始数据，格式为yuv，而OpenGL所能渲染的格式为rgb，因此我们需要使用扩展库中的扩展纹理 GLES11Ext.GL_TEXTURE_EXTERNAL_OES 而它的作用就是实现YUV格","title":"OpenGL ES：配合MediaCodec硬解码渲染（视频加滤镜播放）"}]