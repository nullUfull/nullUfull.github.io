# 面试准备-2023


好久不面试，突然准备面试，其实是挺难受的，就简历这一环节可能都整整花费了我一周的时间去思考、修改。

- 简历：耗时1周，写简历是一件很苦恼的一件事，总觉得自己的简历没啥好写，还是要深度去思考挖掘，可以把做过的项目好好梳理一下，其中的细节、方案的选型以及思考，一一列出来，或许类似逐字稿，这样就比较清晰了，可以重点描述其中的难点，问题是怎么解决的，过程是怎么样的。
- 算法：耗时2周半，《剑指offer》基本看完，题目刷完，后续面试过程中又在持续刷leetcode热题100，虽说面试考察的题型大多数属于链表、树之类的，但偶尔也出现了未遇见过的题目，包括随机数生成之类的，如果时间不充足，还是优先刷热门的题型应付面试比较合适，动态规划可以不用太过于纠结，实际并不就考察到。
- 八股：耗时1周半，面试期间不断查漏补缺
- 项目：耗时1周，面试期间不断优化梳理，包括项目的充实度，可挖掘的东西以及能通过言语体现出来的东西
- 面试技巧：面试过程中不断完善

## 简历
[开发者客栈-在线简历制作](https://www.developers.pub/resume)

简历准备了好久，感觉简历是很难写的

## 复习
- [x] 算法
  - [x] 动态规划
  - [x] 队列
  - [x] 二叉树
  - [x] 栈
  - [x] 回溯
  - [x] 八大排序
    - [x] 堆排序
    - [x] 快速排序
    - [x] 归并排序
    - [x] 冒泡排序
    - [x] 插入排序
    - [x] 计数排序
    - [x] 基数排序
    - [x] 希尔排序
  - [x] 堆
  - [x] 图
    - [x] 拓扑排序
    - [x] bfs；查找图中的最短路径，使用队列实现，可以使用两个队列轮转
    - [x] dfs；查找图中的路径
  - [x] 贪心算法
- [x] 计算机网络
  - [x] TCP|IP
  - [x] 三次握手、四次挥手
- [x] Java
  - [x] 线程池
  - [x] 基础
  - [x] 并发
- [x] Android
  - [x] 基础
    - [x] view绘制流程
    - [x] Handler
    - [x] Binder
    - [x] 事件分发
  - [x] 协程
  - [x] 开源框架
    - [x] OkHttp 
      - [x] 拦截器
      - [x] 连接池
      - [x] 缓存
    - [x] Glide
      - [x] 三级缓存
      - [x] 生命周期感知
      - [x] with load into
    - [x] Retrofit
      - [x] 动态代理
      - [x] 适配器
- [x] 项目梳理+总结

### 算法
#### 为什么01背包和完全背包的状态转移方程存在差异？
[『 一文搞懂完全背包问题 』从0-1背包到完全背包，逐层深入+数学推导](https://leetcode.cn/problems/gaM7Ch/solutions/1501710/by-flix-7gza/)

可以理解完全背包可以多次放入同一物品，所以要再从dp[i]中去找，这也和完全背包内层循环是顺序遍历相呼应。

正因为01背包要考虑到上一行的状态，如果是一维DP，则内层循环需要逆序遍历。

#### 「完全背包问题」内层循环正序，而「0-1 背包问题」中内层循环反序？

是的，完全背包问题和 01 背包问题在实现上的一个区别就是内层循环的顺序不同。

在完全背包问题中，我们可以选择多次放入同一种物品，因此内层循环应该正序遍历背包容量，以便能够考虑放入多个第 i 种物品的情况。具体而言，内层循环应该从 w[i] 开始，遍历到背包容量 j，状态转移方程为：

dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])

其中，dp[i-1][j] 表示在考虑前 i-1 种物品时，背包容量为 j 时的最大价值，dp[i][j-w[i]] + v[i] 表示在考虑前 i 种物品时，背包容量为 j-w[i] 时的最大价值，加上放入一个第 i 种物品的价值 v[i]。

而在 01 背包问题中，每种物品只能选择放或不放，因此内层循环应该倒序遍历背包容量，以确保每个状态只考虑了前面的状态，而不会重复考虑同一个物品。具体而言，内层循环应该从背包容量 j 开始，倒序遍历到 w[i]，状态转移方程为：

dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])

其中，dp[i-1][j] 表示在考虑前 i-1 种物品时，背包容量为 j 时的最大价值，dp[i-1][j-w[i]] + v[i] 表示在考虑前 i-1 种物品时，背包容量为 j-w[i] 时的最大价值，加上放入一个第 i 种物品的价值 v[i]。

### 操作系统

#### 分页
##### 疑问
- 页帧号为什么要左移再加上偏移量?

页帧号左移再加上偏移量是因为在虚拟内存系统中，一个进程的虚拟地址空间被划分为多个固定大小的页（Page）或页面，而物理内存也被划分为相同大小的页框（Page Frame）。

当进程需要访问一个虚拟地址时，操作系统需要将该虚拟地址转换为物理地址，这个转换的过程就叫做地址映射。地址映射的过程包括两个步骤：

1. 将虚拟地址中的页号与物理地址中的页帧号进行映射；
2. 将虚拟地址中的页内偏移量加上物理地址中的页帧内偏移量。

因此，将页帧号左移再加上偏移量的操作实际上是完成了第二步的地址映射操作，将虚拟地址中的页内偏移量加上了物理地址中的页帧内偏移量，从而得到了最终的物理地址。

需要注意的是，页帧号左移的位数是根据页面大小来确定的。例如，如果页面大小为4KB，那么页帧号需要左移12位，因为2的12次方等于4KB。因此，物理地址的前几位是页帧号，后面的几位是页帧内偏移量。


#### 疑问
- [ ] 为什么多队列多处理器调度（MQMS）虽然通过工作窃取（Work Stealing）避免了负载不均的问题，但是就会出现缓存亲和性的问题啊？还是说这个问题相对负载不均并不是那么严重？？？

### Android

#### Android源码

##### Choreographer
[Android Choreographer 源码分析](https://www.cnblogs.com/huansky/p/13912202.html)

#### 基础知识

[用十张图帮你解析RecyclerView的缓存复用机制了！](https://zhuanlan.zhihu.com/p/593837915)

#### 常见的框架

##### Glide
[Android Glide源码剖析系列](https://www.jianshu.com/p/ffce2ad29d0f)

###### 优缺点
优点
1. 内存占用低，Glide默认的Bitmap格式是RGB_565，比ARGB_8888格式的内存开销要小一半，所以图片质量会稍微差一些，当然这些配置都是可以修改的。
2. Glide缓存的图片大小是根据ImageView尺寸来缓存的。这种方式优点是加载显示非常快。且可以设置缓存图片的尺寸
3. 高效处理Bitmap，使用Bitmap Pool来对Bitmap进行复用，主动调用recycle回收需要回收的Bitmap，减小系统回收压力
  
缺点
1. 体积相对来说比较大，目前最新版的大小在500k左右
2. 当我们从远程URL地址下载图片时，Picasso相比Glide要快很多。可能的原因是Picasso下载完图片后直接将整个图片加载进内存，而Glide还需要针对每个ImageView的大小来适配压缩下载到的图片，这个过程需要耗费一定的时间。（当然我们可以使用thumbnail()来减少压缩的时间）

###### 三级缓存
1. 活动缓存；Map<Key,WeakReference>，如果活动缓存没有命中，而内存缓存命中了，则会将内存缓存中的资源移动到活动缓存；如果活动缓存中的资源被标记回收了，则将移除活动缓存，放入内存缓存
2. 内存缓存（LRU）；LinkedHashMap，访问顺序
3. 磁盘缓存（LRU）；保存原图、保存压缩后的图、都保存

###### BitmapPool
Bitmap 复用是指在使用 Bitmap 时，将已经创建过的 Bitmap 对象重新利用，以避免重复创建和销毁 Bitmap 造成的内存和性能消耗。Bitmap 复用的原理是利用 Bitmap 对象的内存块，将 Bitmap 对象的属性和图像数据重置，从而达到重用的目的，这样可以避免频繁的内存分配和回收，提高应用程序的性能和内存使用率。

Bitmap 之所以可以复用，一方面是因为 Bitmap 对象本身是存储在内存中的一块连续的字节数组，只要不释放其内存块，就可以将其包含的属性和图像数据重置，从而复用它。另一方面，是因为 Bitmap 对象的使用周期相对较长，在很多应用场景中，同一个尺寸的 Bitmap 对象会被多次使用，因此进行 Bitmap 复用可以有效地减少内存分配和回收的次数，进而提升应用性能和内存使用率。

Bitmap 复用需要注意以下几点：
1. Bitmap 复用只适用于尺寸和格式相同的 Bitmap 对象。
2. 在 Bitmap 复用的过程中，需要注意复用的 Bitmap 对象是否已经被释放或重置，避免内存泄漏或位图错误。

综上所述，Bitmap 复用是一种有效的内存和性能优化方式，可以通过重用已有的 Bitmap 对象减少内存分配和回收的次数，提高应用程序的性能和内存使用率。

###### 问题
- [ ] 如果Glide的调用在后台线程，则会使用和application生命周期的RequestManager；这是为什么呢？首先想到的就是UI组件肯定得在主线程调用
##### OKHttp

###### 设计模式
- 责任链模式
拦截器链：
1. RetryAndFollowUpInterceptor 重试和重定向拦截器，负责网络请求重定向、重试逻辑
2. BridgeInterceptor 桥接拦截器，从应用程序代码到网络代码的桥梁，首先从用户请求构建网络请求，然后继续调用网络，最后根据网络响应构建用户响应
3. CacheInterceptor 缓存拦截器，请求缓存相关逻辑以及将响应写入缓存，包括缓存策略
4. ConnectInterceptor 连接拦截器，打开与目标服务的连接
5. CallServerInterceptor 请求服务器拦截器，对服务器进行网络调用

开发者可以自行添加拦截器，包括应用拦截器、网络拦截器；

###### 应用拦截器&网络拦截器
应用拦截器处于内部拦截器之前，网络拦截器处于CallServerInterceptor之前，ConnectInterceptor之后。

应用拦截器的proceed肯定会调用一次，网络拦截器的proceed不调用或者调用多次，因为可能命中了缓存或者进行了重试或者重定向。

一般应用拦截器可以用来打印网络请求相关的日志，网络拦截器可以发起网络请求的相关数据。


###### CacheIntercept
主要就是通过缓存策略结合具体的网络或者缓存情况来进行逻辑处理

1. 如果网络请求不可用，且本地没有缓存，则返回504的错误码
2. 如果[不使用缓存][本地没有缓存][缓存过期or失效]，则直接发起网络请求
3. 网络请求回来，[本地有缓存]&&发现远程资源并没有更新[304]，则直接使用缓存
4. 否则判断是否要将请求response进行缓存;[开启缓存策略][response能够缓存]
#### 虚拟机
[dalvik vs art](https://www.jianshu.com/p/1361d1e3a344)

#### Binder

- 为什么AMS和zygote进程通信不用Binder，而是socket？因为fork操作不能在多线程的环境下
[为什么SystemServer进程与Zygote进程通讯采用Socket而不是Binder](https://codeantenna.com/a/jj2VwT8qlS)

##### mmap
mmap是一种内存映射文件的方法，它将一个文件映射到进程的地址空间中，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映的关系。实现这样
的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动会写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必要再调用read、write等系统
调用函数。相反，内核空间对这段内存区域的修改也直接反映用户空间，从而实现不同进程间的数据共享

![pc](https://upload-images.jianshu.io/upload_images/13774375-211e6032044be1ba?imageMogr2/auto-orient/strip|imageView2/2/w/682/format/webp)

##### Android源码应用
1. ContentProvider

我们知道Android的IPC大部分是使用binder，ContentProvider也不例外，如果要传输比较大的文件，binder就不能很好地胜任（binder通信的限制在1M-8k），所以Android采用了匿名内存共享数据来把需要在进程间传输的数据都写到共享内存中去，然后只通过Binder进程间通信机制来传输一个共享内存的文件描述符给对方就好了，对方拿到打开文件描述符就可以对共享内存的数据进行读写。

ContentProvider.openFileDescriptor()

Android系统已经帮我们提供文件共享的实现了 FileProvider

[ContentProvider解析](https://www.cnblogs.com/Robin132929/p/13802700.html)

[ContentProvider原理总结](https://juejin.cn/post/6844904062173839368)

[Android ContentProvider原理总结](https://juejin.cn/post/6844904062173839368)

#### 模块化
##### 模块之间的通信？

单工程->模块化->组件化

模块化：按业务模块来划分
组件化：各个业务会依赖到的可重用的逻辑，比如说日志组件、网络组件、ui组件等

##### 模块之间的通信呢？

我们这边是用的Router，各个模块会依赖Router基础库，向外部暴露统一的接口，注册到Router中，因此各个模块都可以通过Router来获取到其他模块对外暴露的接口，通过Router的中转，依赖接口隔离各个模块的具体的实现逻辑，所以各模块之间的依赖关系是很清晰的。

##### api 对外暴露的类？
   
就是我们各个模块下存在一个api的目录，用于存储本模块对外暴露的接口或者类；这些接口或类在编译的时候，会copy到base_interface的模块，各个业务模块都会
依赖这个基础的模块；除此之外，对外暴露的api通常有一个叫做Service的概念，意外着是这个module对外提供的服务或者能力，这个Service的具体实现是在本模块中。

编译期间各个模块都会生成Service到Service具体实现的一个映射类，Router初始化的时候会调用map将其注册到内存中，由于Service接口在base模块，各个业务模块都能获取到对应的类，各模块只需要通过getService来获取即可，这样通过接口就完全将各模块解耦开来。

### kotlin基础

#### 内联

##### lambda优化
从 Java8 开始，Java 借助 invokedynamic 来完成的 Lambda 的优化。
invokedynamic  用于支持动态语言调用。在首次调用时，它会生成一个调用点，并绑定该调用点对应的方法句柄。后续调用时，直接运行该调用点对应的方法句柄即可。说直白一点，第一次调用 invokeddynamic 时，会找到此处应该运行的方法并绑定， 后续运行时就直接告诉你这里应该执行哪个方法。

[重学 Kotlin —— inline，包治百病的性能良药？](https://juejin.cn/post/6844904201353429006#heading-4)

### Java基础

#### 动态代理
[Android插件化原理解析——Hook机制之动态代理](https://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/)

#### JMM
1. 工作内存和主内存
2. 工作内存和主内存之间存在一套协议
3. 多线程环境下要保证线程之间共享变量的可见性
4. volatile关键字 [java单例模式与指令重排](http://chen-tao.github.io/2016/12/30/about-java-singleton/)

#### 并发

5. 锁优化技术：锁粗化、锁消除、锁升级
6. 偏向锁->轻量级锁->自旋锁->自适应自旋锁->重量级锁
7. monitorenter、monitorexit
8. CAS compare and swap
9. Java线程是基于内核线程实现的，会映射到内核线程，因此线程的切换涉及系统调用，陷入内核态

[死磕 Java 并发编程（7）：读写锁 ReentrantReadWriteLock 源码解析](https://xie.infoq.cn/article/cbcc4fcfc22c3e411ec7a8ee0)

[万字长文，带你深入理解AQS 队列同步器](https://mp.weixin.qq.com/s/DM60_avZYjnTwrm71gJY1g#at)

##### 生产者消费者
- 为什么condition.signal要在lock.unlock之前，这之间的是怎么运作的？
[ReentrantLock中Condition的wait方法、signal方法简单场景回顾](https://codeantenna.com/a/6YTX3qDfFG)

##### ConcurrentHashmap
[深入解析ConcurrentHashMap：感受并发编程智慧](https://segmentfault.com/a/1190000038416595)

### Android
#### ViewModel
1. 生命周期是怎么样的

2.0之前空的Fragment；2.0以后，AndroidX的支持，LifecycleOwner支持

2. Parcelable和Serializable的区别
[每日一问 Parcelable 为什么效率高于 Serializable ？](https://www.wanandroid.com/wenda/show/9002)

### 项目

1. 拍摄页改版
2. 发布页需求：同步到微博、封面支持文字编辑能力、支持话题推荐
3. TavCut接入微视，贴纸
4. 渲染卡顿上报、素材库技术上报、微视蓝领需求、话题详情页改版、 素材库（UI组件）
5. 剪辑、拍摄：音乐混剪、合拍、边看边标（加密视频预览播放）
6. 拍同款：上报，涉及的链路长、拍同款应用

#### 话题列表页
1. MVI Flow搭建Redux核心框架  上报也是使用action
2. 演变 MVI雏形，viewmodel暴露dispatch接口-> 讨论架构，引入redux -> 存在ViewAction和StateAction -> 存在usecase层，抽出viewmodel中可复用的逻辑 -> 新增ReportAction用于上报 -> 引入middleware，usecase中的逻辑迁移到此 -> 去除ViewAction
3. Repository对外暴露数据的接口使用Flow承载
4. 包括为了兼容旧的业务逻辑，以前是存在很多EventBus的方式接受请求回报，统一封装在repository层，对外屏蔽EventBus，这种应该退出历史舞台
5. View可以内部闭环的逻辑就没必要通过Viewmodel去处理了
6. 历史债：使用jce定义的数据结构，非data class，无法做数据diff
7. 为什么UiState下还要区分HasData、NoData
8. 如果列表中的Item的功能足够复杂，所以会拆分为多个区域去处理对应的UI显示以及以及业务逻辑，与此同时，对应的区域存在对应的数据去描述，而且需要处理局部刷新的问题：对比数据变化->UI变化的区域，使用payload去进行刷新，如果用户的一个操作会导致多个UI区域刷新，则需要payload多个数据到recyclerView的item，所以getChangePayload中的逻辑则是这样的：创建一个用于list用于容纳payloads，如果某个区域数据变化，则add该区域的payload数据，对应的区域处理对应的payload
9. EventBus收归到Repository，EventBusRepository，对外提供flow
10. copy不会导致内存爆掉吗？因为state都是用的copy的方式去描述页面状态的变化，答案当然是不会，state的变化并不是深拷贝，而是拷贝所变化的部分，也就是差异化拷贝，可以理解state是一个树状的一个结构，一般来说state树发生变化也只是叶子节点的数据发生变化，每一次的变化不会涉及到整个state的对象的深拷贝，所以内存的压力可以不用考虑

##### MVI优缺点
优点
1. 单向数据流，容易对State的变化进行跟踪和回溯
2. 唯一可信源，减少了复杂性
3. 通过定义的Action以及State就可以快速理解当前的业务逻辑，可以直接当成当前业务的接口文档来看
4. 对State进行集中管理，可以有效减少MVVM架构ViewModel对外暴露的LiveData
5. 可测性好，State的变化的函数是纯函数，有利于单测，80%
6. 可维护性好，后续新增业务逻辑，只需要添加相应的Action，然后处理对应的Action扭转状态

缺点
1. state是不变的，因此每当state需要更新时都要创建新对象替代老对象，这会带来一定内存开销
2. 随着业务的增长，State也会膨胀

##### MVVM的优缺点
缺点
1. 随着业务的增长，ViewModel也会增加，ViewModel中的LiveData等业务逻辑也会增长，维护成本也在增高
2. 多个子模块间要通信，需要持有对应模块的ViewModel，这就意味着需要把对方的ViewModel作用域提升，这样的话如果子模块复杂，互相持有

##### 技术方案选型
响应式的框架，框架的输入是UI的事件，我们抽象定义为Action，框架的输出是UI的状态，UI只需要关心自己所对应的状态数据即可；

1. **【一开始是goggle官方推荐的MVI】** 一开始是按照官方推荐MVI的示例来做的，State由ViewModel持有，UI订阅State，ViewModel对外提供dispatch的接口，参数为Action，UI发送Action事件后，viewModel处理对应事件的业务逻辑并更新State，然后就是存在数据仓库层Repository用于获取页面数据，也存在一个叫做UseCase的层，用于抽取ViewModel中的可通用的业务逻辑，例如点赞、关注
2. **【产生业务思考】** 然后随着业务的开发，发现ViewModel中 一是存在 根据Action去更新State的一个个方法，其次是其他的业务逻辑；然后就思考，State是不是应该有个统一管理的地方呢？联想到我们鹅剪的剪辑框架，基于redux做的，就是统一管理State，有确定的输入和输出，State有对应的reducer去处理，reducer是一个个纯函数
3. **【为什么选择Redux框架？】** 1. redux是这类框架里面最流行的，使用量最多的，当然也有调研过其他的前端状态存储的框架；例如flux、vuex，是多个数据源的 2. 其次呢是我们鹅剪这边有过实践了  更符合MVI架构，单一的数据源，然后我这边就和负责架构的同学提议，可以采用redux框架来管理状态，将状态更新相关的代码可以抽离到一个独立的地方
4. **【LiveData vs FLow】** 然后我这边就开始封装Redux框架，至于为什么我没有直接把鹅剪的框架迁移过来，也做了一些考虑。鹅剪的Redux框架结合LiveData实现，考虑到LiveData的特性，需要在LiveData之上再做一层封装，1. LiveData不支持数据流的，在我们的UI上面，一个Button只需要关注它关注的状态就好了，但给到UI这边是一个大UIState，需要select出它所关注的状态 2. 就是LiveData发送同样的值，订阅者也会收到 而这些特性Flow天热就支持了，考虑到这边团队也在用flow，所以就直接采用Flow+Redux来实现就好了；当然Flow也有一个问题就是LiveData特有的优势，那就是生命周期感应，但是LiveData也是基于LifeCycle来的，一看官方也有提供用于Flow使用的Api，也是基于lifecycle实现的，可以在UI中合理地订阅flow。对，框架就这样搭建起来了，就是简单的Store、Action、State、Reducer这几个主要的概念
5. **【添加middleware】** 后续就是继续提升框架的一个包容性，刚刚我们也说到，我们把State变化的逻辑从ViewModel中抽离了出来，取而代之的是ViewModel持有我们的Store，剩下的就还有一些业务逻辑，比如点赞、关注、拉取页面数据、数据上报等，然后就是引入了middleware的概念，中间件，Action会先从Store的dispatch接口进来，再进入一个个middleware，最后再进入内部的reducer进行状态变化，然后再一层层出来，类似于一个责任链的概念，middleware都有机会接受到Action来处理一些逻辑，例如复杂数据处理、网络请求、数据上报之类的；我们也提供了通用的middleware，例如打印日志
6. **【代码抽离】** 这样我们就可以把ViewModel中剩下的业务逻辑也抽离放置到Redux框架的middleware中了，例如followmiddleware、likemiddleware，fetchDataMiddleware，类似与点赞、关注middleware又持有的是一些usecase，usecase可以在各个页面直接复用，ViewModel就纯粹到只有2个接口，一个是dispatch，一个是uiState
7. **【框架使用优化】** 其次考虑到UI层并未使用声明式的UI框架，如compose，UI层还存在一些UI订阅对应的State的模板代码（启动一个协程，然后select出对应的state，再调用distinctuntilChanged，最后再collect订阅），实属丑陋；采用kotlin扩展函数、中缀表达式、闭包语法优化 简化状态订阅的代码逻辑，框架就基本成型了，后续的需求就可以直接使用了
8.  **【框架使用分享】** 其中我们会制定一些规则以及梳理一些最佳实践的案例，在组内进行分享

#### 拍同款
1. scheme协议设计
   1. 业务场景标记字段 businessType
   2. 通用素材数据定义 MaterialInfo
   3. MaterialInfo编码考虑？Base64 or URL encode？考虑到URL encode对字符长度的增加过大，代码库中有使用Base64编码的先验，因此直接使用Base64编码；同时由于是在URL中进行传输，所以需要考虑Base64的编码模式
2. 通用素材预加载机制：为提升用户的体验，在Router路由框架中添加素材预加载的拦截器，检测到scheme中存在素材则启动预加载逻辑，拉取素材详情并下载素材包；同时在用户打开剪辑页的拦截器，如果素材未加载成功则显示全屏的Loading，否则不拦截；
3. 异常处理逻辑：包括版权素材不可剪情况下的异常提示（无版权）、视频换链失败异常提示、
4. 封装通用的放号授权逻辑：参考Glide的实现封装到一个空的Fragment中，对外提供统一的接口；在落地页，如剪辑页、拍摄页进行弹窗授权
5. 正确上报用户视频使用素材：尽量保证修改所影响的范围，梳理各个场景的逻辑，增补相应的字段即可；其中也发现了问题，当时是后台同学发现存在上报的字符串被截断了的case，后台同学排查发现数据入库存在字符串长度限制（6000），同时端上也找到了上报的素材存在超长的case（例如在剪辑工具下使用了各种素材），意味着端上上报需要按照产品定义的优先级去尽量上报素材，并且限制每种类型的素材的上报数量限制；
6. 版本兼容机制；低版本刷到高版本才支持的xx拍同款，需要提示用户升级；scheme中会携带min_version，Router中添加版本拦截器用于校验版本

#### 合拍

##### 背景
在原有的合拍基础上升级，原有的合拍逻辑：用户可以选择一个视频素材进行合拍，分别支持布局：左右布局、上下布局、画中画类型，用户拍摄完成以后会合成一个视频给到剪辑模块；
升级：用户拍摄完成以后，输出两个视频到剪辑模块，一个是录制的视频一个是素材视频，并且按照拍摄页的布局排布视频

1. 修改渲染链逻辑，合拍节点输出2个纹理，一个视频相机预览的纹理，一个是相机预览和素材视频合在一起的纹理
2. 在原有的剪辑能力上支持对2个视频的布局还原三种类型的布局，剪辑页目前的能力是只存在一条主轨视频，如果需要两个素材视频同时显示，只能考虑画中画的方案（主轨道视频与画中画视频存在层次关系），因此左右、上下布局的视频以录制的视频为主轨视频，素材视频为画中画视频；
3. 定义模块间交互的数据结构，保证模块间交互是解耦的，也就是说确定好剪辑模块的输入，例如DuetApplyModel

#### 封面页重构
##### 背景
当时是有一个业务需求需要发布模块的封面选择模块需要支持添加文字贴纸的能力，而当时封面模块的现状是只能从视频中截取一帧；问题的关键就在于我们怎么支持渲染的能力
##### 方案选型

逆向思考，将封面模块迁移到编辑模块，利用编辑模块的渲染能力以支持封面编辑的新功能，然后就是对封面模块进行解耦封装，接入贴纸渲染能力，设计新的草稿字段以存储封面页的贴纸

##### 成果
1. 将封面选择的逻辑解耦了出来，保持模块单一的职责，有确定的输入和输出
2. 统一多业务场景的封面选择逻辑，提高了可维护性
3. bug率很小

#### 草稿

##### 向前兼容
如果是传统地定义一个类，用来定义草稿的数据结构

如下问题：
版本1：新增了 tag:String
版本2：删除了 tag字段
版本3：新增了 tag:Int

版本3的App打开版本1的草稿的时候就会出现反序列化失败的问题

##### 草稿字段定义
1. 草稿文件加锁，需要特定同学审批才能通过 
2. 草稿字段不能删除，只能标记废弃

##### 草稿存储
存储到数据库，sqlite，room

blob写入大数据

##### 自动保存临时草稿数据
常规方案：
1. 使⽤定时器固定时间间隔执⾏保存编辑状态；时间间隔内编辑操作不能保证存储
2. 依赖⽣命周期回调，在⽤户离开编辑场景时⾃动保存；Crash 等异常发⽣时不会触发⽣命周期回调

最终方案：
存储时机：用户每次更新草稿就应该保存下来，为了防止进程被杀、闪退之类的，草稿没有办法正常存储下来，导致草稿丢失
保存方式：使用mmkv，mmap

##### 撤销&回退
###### 命令式
命令式实现的撤销与重做，在历史记录中保存的是操作命令（或者说方法），而且是每次保存两个命令。

针对用户的每一次操作，都写一个正向操作方法和逆操作方法，统一提交到一个命令执行器中。命令执行器会保存这样一对方法，并立即执行正向操作方法。当需要撤销这步操作时，执行对应的逆操作方法，回到当次操作之前的状态；重做时，再执行正向操作方法。

命令执行器不关心当前应用的数据状态，只关注执行了什么命令。在实现时，需要有两个数组，一个用来保存可撤销的历史，一个用来保存可重做的历史。

问题：
1. 在应用开发过程中，必须持续关注撤销重做功能；因为每一个操作都要写逆操作方法。当你对数据有不同的变更方式时，随即也要写出相应的逆操作方法
2. 有些操作的逆操作可能写起来比较困难
3. 撤销重做只能在相邻的操作记录中进行；如果要从s4状态撤销到s1状态，中间必须经过s3、s2状态

###### 快照式
保存历史状态
 
优势
1. 不关心具体的变化，通用型强
2. 撤销重做只涉及指针的移动

劣势
内存占用

难点
1. 如何保证历史快照中的数据不会被篡改
2. 避免快照式深拷贝带来的性能影响

解决思路
每次gitncommitn都会⽣成⼀个新版本，但是 git仓库⼤⼩不会每次double，因为它没有将未修改⽂件拷贝

解决方案
1. 使用kotlin的data class + val 定义使状态不可变
2. 使用data class的copy，不需要进行完全的深拷贝，只需要对变化的数据进行拷贝即可，未改变的数据进行浅拷贝

## 面试题目

- 聊一下 Binder 的实现，如果让你 hook binder 拿到 binder 里面传输的数据你会怎么做
[Android知识体系之Binder Hook](https://www.zybuluo.com/TryLoveCatch/note/2287028)
- MVC & MVP & MVVM，这么多设计模式你都用过，你觉得哪个更好，他们之前主要的差别是什么
[Android架构学习之路三-MVX](https://ljd1996.github.io/2022/01/11/Android%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E4%B8%89-MVX/)
- 聊一下 coroutines 的底层实现
- 你做过什么性能优化？

开放性问题
- 你对自己有什么规划 
1. 就是希望自己能够继续成长吧，因为目前自我感觉距离高级工程师还有不少差距，项目的经验、接触的东西、以及深度还不够 
2. 为了达成这样一个目标，就是保持长期进行技术学习的一个习惯，不限于新的技术，比如说compose、kmm，可以趁着新技术的发展深入地学习一波，随着技术的发展，自己也能积累到不错的东西，例如一些通用的知识或者解决方案；
3. 其次还包括一些经典框架的源码分析、基础架构、框架层面的架构能力；
4. 然后是持续学习基础方面的知识，比如操作系统、Linux的一些知识还需要不断地修炼；
5. 最后就是需要保持blog的输出和沉淀
- 最近在关注什么新的技术？最近关注的是nowinandroid这个项目、compose、kmm
- 有没有做过一下性能优化的例子，展开讲讲 
有做过，只是做的东西比较小；比如说我们这边有个需求是需要在请求头里面携带上我们所使用的底层渲染库的版本以及所支持的能力的版本号，以便后台可以下发合适的素材，light、pag，一开始是直接使用的这些库提供的native接口去获取，如果这些库so没有load，则会先去load，虽说这样一看是没什么问题；但是后面发现会影响到App的冷启动，导致耗时会增加100ms，后续做的一个优化是将这些库的版本号写在gralde文件里面，然后可以通过BuildConfig去读取，这样读取就不会存在什么耗时了；虽然说这样存在弊端，就是人为去更新这些版本可能会存在问题，比如说忘记更新了或者更新错了，所以又补充了一个先从网络获取配置的逻辑，如果能正常读取到则用后台配置的，否则用本地的，这样就为了防止本地配置错误加了一个兜底的逻辑
- 如果加入我们，你觉得会给团队带来什么？我想知道如果我加入你们，会让我承担一个怎么样的角色或者说我会负责哪方面的东西？虽然说项目的方向对我来说是一个比较新的东西，但是我想以我的学习能力与热情，我会随着项目快速成长起来，能够承担更重要的角色，同时会保证项目的交付质量以及代码的质量
（首先先明确自己需要在团队内承担一个怎么样的角色，是需要反问的。其次再表明自己的决心，以及对工作的热爱，无非就是保证需求、项目交付的质量，虽然说对自己可能是一个比较新的东西，但也要表明要把它吃透的决心，而且希望自己能够快速成长起来，能够承担更重要的角色）
