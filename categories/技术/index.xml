<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>技术 on FineSnow&#39;s Blog</title>
    <link>/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on FineSnow&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 01 Jun 2022 18:27:14 +0000</lastBuildDate><atom:link href="/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mvi</title>
      <link>/posts/tech/mvi/</link>
      <pubDate>Wed, 01 Jun 2022 18:27:14 +0000</pubDate>
      
      <guid>/posts/tech/mvi/</guid>
      <description>简介 MVI 与 MVVM 比较相似，其借鉴了前端框架的思想，着重强调数据的单向流动和唯一数据源 优势 强调数据单向流动，很容易对状态变化进行跟踪和回溯 使用Vie</description>
    </item>
    
    <item>
      <title>不错的技术文章</title>
      <link>/posts/tech/%E4%B8%8D%E9%94%99%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/</link>
      <pubDate>Sat, 29 May 2021 18:27:14 +0000</pubDate>
      
      <guid>/posts/tech/%E4%B8%8D%E9%94%99%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/</guid>
      <description>kotlin Android-Redux-Intro 协程 Coroutines : First things first 如何优雅的取消协程 ？ Kotlin Coroutines(协程) 完全解析（三），封装异步回调、协程间关系及协程的取消 [译] 如何优雅的处理</description>
    </item>
    
    <item>
      <title>gradle.properties中定义变量</title>
      <link>/posts/tech/gradle.properties%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F/</link>
      <pubDate>Thu, 29 Apr 2021 18:27:14 +0000</pubDate>
      
      <guid>/posts/tech/gradle.properties%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F/</guid>
      <description>gradle.properties中定义变量 1 light_sdk_version = 2.2.5.14 build.gradle中使用 现在gradle中定义一个函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14</description>
    </item>
    
    <item>
      <title>OpenGL ES：视频加滤镜后导出</title>
      <link>/posts/tech/opengl-es%E8%A7%86%E9%A2%91%E5%8A%A0%E6%BB%A4%E9%95%9C%E5%90%8E%E5%AF%BC%E5%87%BA/</link>
      <pubDate>Sun, 04 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/tech/opengl-es%E8%A7%86%E9%A2%91%E5%8A%A0%E6%BB%A4%E9%95%9C%E5%90%8E%E5%AF%BC%E5%87%BA/</guid>
      <description>视频加滤镜播放 MediaCodec解码——&amp;gt;OpenGL es——&amp;gt; GLSurfaceView 视频滤镜合成导出 MediaCodec解码——&amp;gt;Open</description>
    </item>
    
    <item>
      <title>OpenGL ES：配合MediaCodec硬解码渲染（视频加滤镜播放）</title>
      <link>/posts/tech/opengl-es%E9%85%8D%E5%90%88mediacodec%E7%A1%AC%E8%A7%A3%E7%A0%81%E6%B8%B2%E6%9F%93%E8%A7%86%E9%A2%91%E5%8A%A0%E6%BB%A4%E9%95%9C%E6%92%AD%E6%94%BE/</link>
      <pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/tech/opengl-es%E9%85%8D%E5%90%88mediacodec%E7%A1%AC%E8%A7%A3%E7%A0%81%E6%B8%B2%E6%9F%93%E8%A7%86%E9%A2%91%E5%8A%A0%E6%BB%A4%E9%95%9C%E6%92%AD%E6%94%BE/</guid>
      <description>注意点 MediaCodec 解码后的原始数据，格式为yuv，而OpenGL所能渲染的格式为rgb，因此我们需要使用扩展库中的扩展纹理 GLES11Ext.GL_TEXTURE_EXTERNAL_OES 而它的作用就是实现YUV格</description>
    </item>
    
  </channel>
</rss>
